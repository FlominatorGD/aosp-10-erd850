/*
 * Copyright (c) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define LOG_TAG "RIL_EXTERNAL"

#include <vendor/samsung_slsi/telephony/hardware/radioExternal/1.0/IOemSlsiRadioExternal.h>

#include <hwbinder/IPCThreadState.h>
#include <hwbinder/ProcessState.h>
#include <hidl/HidlTransportSupport.h>
#include <utils/SystemClock.h>
#include <inttypes.h>

#include <slsi/ril_client.h>
#include <slsi/ril_oem.h>
#include "ril_external_service.h"

// Enable verbose logging
#define RIL_EXTERN_VDBG 0

using namespace vendor::samsung_slsi::telephony::hardware::radioExternal::V1_0;
using ::android::hardware::configureRpcThreadpool;
using ::android::hardware::joinRpcThreadpool;
using ::android::hardware::Return;
using ::android::hardware::hidl_string;
using ::android::hardware::hidl_vec;
using ::android::hardware::hidl_array;
using ::android::hardware::Void;
using android::sp;

#define EXTERNAL_CALL_ONREQUEST(a, b, c, d, e) \
        s_external_vendorFunctions->externalOnRequest((a), (b), (c), (d), ((RIL_SOCKET_ID)(e)))

#define MAX_NUM_REQ_RAW_SEGMENT (5)
#define MAX_RADIO_DATA_SIZE (1 << 11)    // set 2's multiplier
#define MAX_RADIO_DATA_MOD (MAX_RADIO_DATA_SIZE - 1)

static RIL_RadioExternalFunctions s_external_vendorCallbacks = {0, NULL};
static RIL_RadioExternalFunctions *s_external_vendorFunctions = NULL;
static int s_external_registerCalled = 0;

static pthread_mutex_t s_external_pendingRequestsMutex = PTHREAD_MUTEX_INITIALIZER;
static RadioExternalRequestInfo *s_external_pendingRequests = NULL;
static pthread_rwlock_t radioExternalServiceRwlock = PTHREAD_RWLOCK_INITIALIZER;

struct RadioExternalImpl;
sp<RadioExternalImpl> radioExeternalService[1];
volatile int32_t mCounterRadioExternalClient[(int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM];

radioExternal_responseFunction getResponseFunction(int request) {
    if (request == RILC_REQ_GET_AVAILABLE_NETWORKS) {
        return radioExternal::getAvailableNtworksResponse;
    }
    return radioExternal::sendRequestRawResponse;
}

struct RequestRawSegmentData{
    uint8_t *pData = NULL;
    int32_t serial;
    int32_t clientId;
    int32_t rilcReqId;
    int32_t slotId;
    int32_t totalLen;
    int32_t accLen;

    void reset() {
        delete[] pData;
        pData = NULL;
        serial = -1;
        clientId = -1;
        rilcReqId = -1;
        slotId = -1;
        totalLen = 0;
        accLen = 0;
    }
}reqRawSegData[MAX_NUM_REQ_RAW_SEGMENT];

static const char *rilcRequestToString(int rilcReqId) {
    switch (rilcReqId) {
        case RILC_REQ_SYSTEM_MODEM_DUMP: return "RIL_REQUEST_OEM_MODEM_DUMP";
        case RILC_REQ_MISC_SET_ENG_MODE: return "RIL_REQUEST_OEM_SET_ENG_MODE";
        case RILC_REQ_MISC_SCREEN_LINE: return "RIL_REQUEST_OEM_SET_SCR_LINE";
        case RILC_REQ_MISC_DEBUG_TRACE: return "RIL_REQUEST_OEM_SET_DEBUG_TRACE";
        case RILC_REQ_MISC_SET_CARRIER_CONFIG: return "RIL_REQUEST_OEM_SET_CARRIER_CONFIG";
        case RILC_REQ_MISC_SET_ENG_STRING_INPUT: return "RIL_REQUEST_OEM_SET_ENG_STRING_INPUT";
        case RILC_REQ_MISC_APN_SETTINGS: return "RIL_REQUEST_OEM_APN_SETTINGS";
        case RILC_REQ_MISC_GET_MSL_CODE: return "RIL_REQUEST_OEM_GET_MSL_CODE";
        case RILC_REQ_MISC_SET_PIN_CONTROL: return "RIL_REQUEST_OEM_SET_PIN_CONTROL";
        case RILC_REQ_MISC_SET_PREFERRED_CALL_CAPA: return "RILC_REQ_MISC_SET_PREFERRED_CALL_CAPA";
        case RILC_REQ_MISC_GET_PREFERRED_CALL_CAPA: return "RILC_REQ_MISC_GET_PREFERRED_CALL_CAPA";
        case RILC_REQ_MISC_GET_MANUAL_BAND_MODE: return "RIL_REQUEST_OEM_GET_MANUAL_BAND_MODE";
        case RILC_REQ_MISC_SET_MANUAL_BAND_MODE: return "RIL_REQUEST_OEM_SET_MANUAL_BAND_MODE";
        case RILC_REQ_MISC_GET_RF_DESENSE_MODE: return "RIL_REQUEST_OEM_GET_RF_DESENSE_MODE";
        case RILC_REQ_MISC_SET_RF_DESENSE_MODE: return "RIL_REQUEST_OEM_SET_RF_DESENSE_MODE";
        case RILC_REQ_MISC_STORE_ADB_SERIAL_NUMBER: return "RIL_REQUEST_OEM_STORE_ADB_SERIAL_NUMBER";
        case RILC_REQ_MISC_READ_ADB_SERIAL_NUMBER: return "RIL_REQUEST_OEM_READ_ADB_SERIAL_NUMBER";
        case RILC_REQ_GET_MANUAL_RAT_MODE: return "RIL_REQUEST_OEM_GET_MANUAL_RAT_MODE";
        case RILC_REQ_SET_MANUAL_RAT_MODE: return "RIL_REQUEST_OEM_SET_MANUAL_RAT_MODE";
        case RILC_REQ_GET_FREQUENCY_LOCK: return "RIL_REQUEST_OEM_GET_FREQUENCY_LOCK";
        case RILC_REQ_SET_FREQUENCY_LOCK: return "RIL_REQUEST_OEM_SET_FREQUENCY_LOCK";
        case RILC_REQ_SET_ENDC_MODE: return "RIL_REQUEST_OEM_SET_ENDC_MODE";
        case RILC_REQ_GET_ENDC_MODE: return "RIL_REQUEST_OEM_GET_ENDC_MODE";
        case RILC_REQ_SCAN_RSSI: return "RILC_REQ_SCAN_RSSI";
        case RILC_REQ_FORWARDING_AT_COMMAND: return "RILC_REQ_FORWARDING_AT_COMMAND";
        case RILC_REQ_AUDIO_SET_MUTE: return "RILC_REQ_AUDIO_SET_MUTE";
        case RILC_REQ_AUDIO_GET_MUTE: return "RILC_REQ_AUDIO_GET_MUTE";
        case RILC_REQ_AUDIO_SET_VOLUME: return "RILC_REQ_AUDIO_SET_VOLUME";
        case RILC_REQ_AUDIO_GET_VOLUME: return "RILC_REQ_AUDIO_GET_VOLUME";
        case RILC_REQ_AUDIO_SET_PATH: return "RILC_REQ_AUDIO_SET_PATH";
        case RILC_REQ_AUDIO_GET_PATH: return "RILC_REQ_AUDIO_GET_PATH";
        case RILC_REQ_AUDIO_SET_MIC: return "RILC_REQ_AUDIO_SET_MIC";
        case RILC_REQ_AUDIO_GET_MIC: return "RILC_REQ_AUDIO_GET_MIC";
        case RILC_REQ_AUDIO_SET_AUDIO_CLOCK: return "RILC_REQ_AUDIO_SET_AUDIO_CLOCK";
        case RILC_REQ_AUDIO_SET_AUDIO_LOOPBACK: return "RILC_REQ_AUDIO_SET_AUDIO_LOOPBACK";
        case RILC_REQ_AUDIO_SET_TTY_MODE: return "RILC_REQ_AUDIO_SET_TTY_MODE";
        case RILC_REQ_GET_AVAILABLE_NETWORKS: return "RILC_REQ_GET_AVAILABLE_NETWORKS";
        case RILC_REQ_GET_FREQUENCY_INFO: return "RILC_REQ_GET_FREQUENCY_INFO";

        case RILC_REQ_IMS_SET_CONFIGURATION: return "RIL_REQUEST_OEM_IMS_SET_CONFIGURATION";
        case RILC_REQ_IMS_GET_CONFIGURATION: return "RIL_REQUEST_OEM_IMS_GET_CONFIGURATION";
        case RILC_REQ_IMS_SIM_AUTH: return "RIL_REQUEST_OEM_IMS_SIM_AUTH";
        case RILC_REQ_IMS_SET_EMERGENCY_CALL_STATUS: return "RIL_REQUEST_OEM_IMS_SET_EMERGENCY_CALL_STATUS";
        case RILC_REQ_IMS_SET_SRVCC_CALL_LIST: return "RIL_REQUEST_OEM_IMS_SET_SRVCC_CALL_LIST";
        case RILC_REQ_IMS_GET_GBA_AUTH: return "RIL_REQUEST_OEM_IMS_GET_GBA_AUTH";
        case RILC_REQ_IMS_SIM_IO: return "RIL_REQUEST_OEM_IMS_SIM_IO";
        case RILC_REQ_NET_GET_IMS_SUPPORT_SERVICE: return "RIL_REQUEST_OEM_GET_IMS_SUPPORT_SERVICE";

        /* GPS */
        case RILC_REQ_GPS_SET_FREQUENCY_AIDING: return "RIL_REQUEST_OEM_GPS_SET_FREQUENCY_AIDING";
        case RILC_REQ_GPS_GET_LPP_SUPL_REQ_ECID_INFO: return "RIL_REQUEST_OEM_GPS_GET_LPP_SUPL_REQ_ECID_INFO";
        case RILC_REQ_GPS_SET_RRLP_SUPL_REQ_ECID_INFO: return "RIL_REQUEST_OEM_GPS_SET_RRLP_SUPL_REQ_ECID_INFO";
        case RILC_REQ_GPS_MO_LOCATION_REQUEST: return "RIL_REQUEST_OEM_GPS_MO_LOCATION_REQUEST";
        case RILC_REQ_GPS_GET_LPP_REQ_SERVING_CELL_INFO: return "RIL_REQUEST_OEM_GPS_GET_LPP_REQ_SERVING_CELL_INFO";
        case RILC_REQ_GPS_SET_SUPL_NI_READY: return "RIL_REQUEST_OEM_GPS_SET_SUPL_NI_READY";
        case RILC_REQ_GPS_MEASURE_POS_RSP : return "RIL_REQUEST_OEM_GPS_MEASURE_POS_RSP";
        case RILC_REQ_GPS_RELEASE_GPS : return "RIL_REQUEST_OEM_GPS_RELEASE_GPS";
        case RILC_REQ_GPS_MT_LOCATION_REQUEST: return "RIL_REQUEST_OEM_GPS_MT_LOCATION_REQUEST";
        case RILC_REQ_GPS_LPP_PROVIDE_CAPABILITIES: return "RIL_REQUEST_OEM_GPS_LPP_PROVIDE_CAPABILITIES";
        case RILC_REQ_GPS_LPP_REQUEST_ASSIST_DATA: return "RIL_REQUEST_OEM_GPS_LPP_REQUEST_ASSIST_DATA";
        case RILC_REQ_GPS_LPP_PROVIDE_LOCATION_INFO: return " RIL_REQUEST_OEM_GPS_LPP_PROVIDE_LOCATION_INFO";
        case RILC_REQ_GPS_LPP_GPS_ERROR_IND: return "RIL_REQUEST_OEM_GPS_LPP_GPS_ERROR_IND";
        case RILC_REQ_GPS_SUPL_LPP_DATA_INFO: return "RIL_REQUEST_OEM_GPS_SUPL_LPP_DATA_INFO";
        case RILC_REQ_GPS_SUPL_NI_MESSAGE: return "RIL_REQUEST_OEM_GPS_SUPL_NI_MESSAGE";
        case RILC_REQ_GPS_SET_GANSS_MEAS_POS_RSP: return "RIL_REQUEST_OEM_GPS_SET_GANSS_MEAS_POS_RSP";
        case RILC_REQ_GPS_SET_GPS_LOCK_MODE: return "RIL_REQUEST_OEM_GPS_SET_GPS_LOCK_MODE";
        case RILC_REQ_GPS_GET_REFERENCE_LOCATION: return "RIL_REQUEST_OEM_GPS_GET_REFERENCE_LOCATION";
        case RILC_REQ_GPS_SET_PSEUDO_RANGE_MEASUREMENTS: return "RIL_REQUEST_OEM_GPS_SET_PSEUDO_RANGE_MEASUREMENTS";
        case RILC_REQ_GPS_GET_CDMA_PRECISE_TIME_AIDING_INFO: return "RIL_REQUEST_OEM_GPS_GET_CDMA_PRECISE_TIME_AIDING_INFO";
        case RILC_REQ_GPS_GANSS_AP_POS_CAP_RSP: return "RIL_REQUEST_OEM_GPS_GANSS_AP_POS_CAP_RSP";
        case RILC_REQ_GPS_GET_GSM_EXT_INFO_MSG: return "RIL_REQUEST_OEM_GPS_GET_GSM_EXT_INFO_MSG";
        case RILC_REQ_GPS_CONTROL_PLANE_ENABLE: return "RIL_REQUEST_OEM_GPS_CONTROL_PLANE_ENABLE";
        case RILC_REQ_GPS_GNSS_LPP_PROFILE_SET: return "RIL_REQUEST_OEM_GPS_GNSS_LPP_PROFILE_SET";
        case RILC_REQ_GPS_RETRIEVE_LOC_INFO: return "RIL_REQUEST_OEM_GPS_RETRIEVE_LOC_INFO";
        case RILC_REQ_GPS_CDMA_FREQ_AIDING: return "RIL_REQUEST_OEM_GPS_CDMA_FREQ_AIDING";

        case RILC_REQ_WLAN_GET_IMSI: return "RIL_REQUEST_GET_IMSI";
        case RILC_REQ_WLAN_SIM_AUTHENTICATE: return "RIL_REQUEST_OEM_SIM_AUTHENTICATION";
        case RILC_REQ_IF_EXECUTE_AM: return "RIL_REQUEST_OEM_IF_EXECUTE_AM";

        //AIMS support start ---------------------
        case RILC_REQ_AIMS_DIAL: return "RIL_REQUEST_OEM_AIMS_DIAL";
        case RILC_REQ_AIMS_ANSWER: return "RIL_REQUEST_OEM_AIMS_ANSWER";
        case RILC_REQ_AIMS_HANGUP: return "RIL_REQUEST_OEM_AIMS_HANGUP";
        case RILC_REQ_AIMS_DEREGISTRATION: return "RIL_REQUEST_OEM_AIMS_DEREGISTRATION";
        case RILC_REQ_AIMS_HIDDEN_MENU: return "RIL_REQUEST_OEM_AIMS_HIDDEN_MENU";
        case RILC_REQ_AIMS_ADD_PDN_INFO: return "RIL_REQUEST_OEM_AIMS_ADD_PDN_INFO";
        case RILC_REQ_AIMS_CALL_MANAGE: return "RIL_REQUEST_OEM_AIMS_CALL_MANAGE";
        case RILC_REQ_AIMS_SEND_DTMF: return "RIL_REQUEST_OEM_AIMS_SEND_DTMF";
        case RILC_REQ_AIMS_SET_FRAME_TIME: return "RIL_REQUEST_OEM_AIMS_SET_FRAME_TIME";
        case RILC_REQ_AIMS_GET_FRAME_TIME: return "RIL_REQUEST_OEM_AIMS_GET_FRAME_TIME";
        case RILC_REQ_AIMS_CALL_MODIFY: return "RIL_REQUEST_OEM_AIMS_CALL_MODIFY";
        case RILC_REQ_AIMS_RESPONSE_CALL_MODIFY: return "RIL_REQUEST_OEM_AIMS_RESPONSE_CALL_MODIFY";
        case RILC_REQ_AIMS_TIME_INFO: return "RIL_REQUEST_OEM_AIMS_TIME_INFO";
        case RILC_REQ_AIMS_CONF_CALL_ADD_REMOVE_USER: return "RIL_REQUEST_OEM_AIMS_CONF_CALL_ADD_REMOVE_USER";
        case RILC_REQ_AIMS_ENHANCED_CONF_CALL: return "RIL_REQUEST_OEM_AIMS_ENHANCED_CONF_CALL";
        case RILC_REQ_AIMS_GET_CALL_FORWARD_STATUS: return "RIL_REQUEST_OEM_AIMS_GET_CALL_FORWARD_STATUS";
        case RILC_REQ_AIMS_SET_CALL_FORWARD_STATUS: return "RIL_REQUEST_OEM_AIMS_SET_CALL_FORWARD_STATUS";
        case RILC_REQ_AIMS_GET_CALL_WAITING: return "RIL_REQUEST_OEM_AIMS_GET_CALL_WAITING";
        case RILC_REQ_AIMS_SET_CALL_WAITING: return "RIL_REQUEST_OEM_AIMS_SET_CALL_WAITING";
        case RILC_REQ_AIMS_GET_CALL_BARRING: return "RIL_REQUEST_OEM_AIMS_GET_CALL_BARRING";
        case RILC_REQ_AIMS_SET_CALL_BARRING: return "RIL_REQUEST_OEM_AIMS_SET_CALL_BARRING";
        case RILC_REQ_AIMS_SEND_SMS: return "RIL_REQUEST_OEM_AIMS_SEND_SMS";
        case RILC_REQ_AIMS_SEND_EXPECT_MORE: return "RIL_REQUEST_OEM_AIMS_SEND_EXPECT_MORE";
        case RILC_REQ_AIMS_SEND_SMS_ACK: return "RIL_REQUEST_OEM_AIMS_SEND_SMS_ACK";
        case RILC_REQ_AIMS_SEND_ACK_INCOMING_SMS: return "RIL_REQUEST_OEM_AIMS_SEND_ACK_INCOMING_SMS";
        case RILC_REQ_AIMS_CHG_BARRING_PWD: return "RIL_REQUEST_OEM_AIMS_CHG_BARRING_PWD";
        case RILC_REQ_AIMS_SEND_USSD_INFO: return "RIL_REQUEST_OEM_AIMS_SEND_USSD_INFO";
        case RILC_REQ_AIMS_GET_PRESENTATION_SETTINGS: return "RIL_REQUEST_OEM_AIMS_GET_PRESENTATION_SETTINGS";
        case RILC_REQ_AIMS_SET_PRESENTATION_SETTINGS: return "RIL_REQUEST_OEM_AIMS_SET_PRESENTATION_SETTINGS";
        case RILC_REQ_AIMS_SET_SELF_CAPABILITY: return "RIL_REQUEST_OEM_AIMS_SET_SELF_CAPABILITY";
        case RILC_REQ_AIMS_HO_TO_WIFI_READY: return "RIL_REQUEST_OEM_AIMS_HO_TO_WIFI_READY";
        case RILC_REQ_AIMS_HO_TO_WIFI_CANCEL_IND: return "RIL_REQUEST_OEM_AIMS_HO_TO_WIFI_CANCEL_IND";
        case RILC_REQ_AIMS_HO_PAYLOAD_IND: return "RIL_REQUEST_OEM_AIMS_HO_PAYLOAD_IND";
        case RILC_REQ_AIMS_HO_TO_3GPP: return "RIL_REQUEST_OEM_AIMS_HO_TO_3GPP";
        case RILC_REQ_AIMS_SEND_ACK_INCOMING_CDMA_SMS: return "RIL_REQUEST_OEM_AIMS_SEND_ACK_INCOMING_CDMA_SMS";
        case RILC_REQ_AIMS_MEDIA_STATE_IND: return "RIL_REQUEST_OEM_AIMS_MEDIA_STATE_IND";
        case RILC_REQ_AIMS_DEL_PDN_INFO: return "RIL_REQUEST_OEM_AIMS_DEL_PDN_INFO";
        case RILC_REQ_AIMS_STACK_START_REQ: return "RIL_REQUEST_OEM_AIMS_STACK_START_REQ";
        case RILC_REQ_AIMS_STACK_STOP_REQ: return "RIL_REQUEST_OEM_AIMS_STACK_STOP_REQ";
        case RILC_REQ_AIMS_XCAPM_START_REQ: return "RIL_REQUEST_OEM_AIMS_XCAPM_START_REQ";
        case RILC_REQ_AIMS_XCAPM_STOP_REQ: return "RIL_REQUEST_OEM_AIMS_XCAPM_STOP_REQ";
        case RILC_REQ_AIMS_RTT_SEND_TEXT: return "RIL_REQUEST_OEM_AIMS_RTT_SEND_TEXT";
        case RILC_REQ_AIMS_EXIT_EMERGENCY_CB_MODE: return "RIL_REQUEST_OEM_AIMS_EXIT_EMERGENCY_CB_MODE";
        case RILC_REQ_AIMS_SET_GEO_LOCATION_INFO: return "RIL_REQUEST_OEM_AIMS_SET_GEO_LOCATION_INFO";
        case RILC_REQ_AIMS_CDMA_SEND_SMS: return "RIL_REQUEST_OEM_AIMS_CDMA_SEND_SMS";
        case RILC_REQ_AIMS_RCS_MULTI_FRAME: return "RIL_REQUEST_OEM_AIMS_RCS_MULTI_FRAME";
        case RILC_REQ_AIMS_RCS_CHAT: return "RIL_REQUEST_OEM_AIMS_RCS_CHAT";
        case RILC_REQ_AIMS_RCS_GROUP_CHAT: return "RIL_REQUEST_OEM_AIMS_RCS_GROUP_CHAT";
        case RILC_REQ_AIMS_RCS_OFFLINE_MODE: return "RIL_REQUEST_OEM_AIMS_RCS_OFFLINE_MODE";
        case RILC_REQ_AIMS_RCS_FILE_TRANSFER: return "RIL_REQUEST_OEM_AIMS_RCS_FILE_TRANSFER";
        case RILC_REQ_AIMS_RCS_COMMON_MESSAGE: return "RIL_REQUEST_OEM_AIMS_RCS_COMMON_MESSAGE";
        case RILC_REQ_AIMS_RCS_CONTENT_SHARE: return "RIL_REQUEST_OEM_AIMS_RCS_CONTENT_SHARE";
        case RILC_REQ_AIMS_RCS_PRESENCE: return "RIL_REQUEST_OEM_AIMS_RCS_PRESENCE";
        case RILC_REQ_AIMS_XCAP_MANAGE: return "RIL_REQUEST_OEM_AIMS_XCAP_MANAGE";
        case RILC_REQ_AIMS_RCS_CONFIG_MANAGE: return "RIL_REQUEST_OEM_AIMS_RCS_CONFIG_MANAGE";
        case RILC_REQ_AIMS_RCS_TLS_MANAGE: return "RIL_REQUEST_OEM_AIMS_RCS_TLS_MANAGE";
        case RILC_REQ_AIMS_SET_PDN_EST_STATUS: return "RIL_REQUEST_OEM_AIMS_SET_PDN_EST_STATUS";
        case RILC_REQ_AIMS_SET_HIDDEN_MENU_ITEM: return "RILC_REQ_AIMS_SET_HIDDEN_MENU_ITEM";
        case RILC_REQ_AIMS_GET_HIDDEN_MENU_ITEM: return "RILC_REQ_AIMS_GET_HIDDEN_MENU_ITEM";
        case RILC_REQ_AIMS_SET_RTP_RX_STATISTICS: return "RIL_REQUEST_OEM_AIMS_SET_RTP_RX_STATISTICS";
        //AIMS support end ---------------------

        //WFC
        case RILC_REQ_WFC_MEDIA_CHANNEL_CONFIG: return "RIL_REQUEST_OEM_WFC_MEDIA_CHANNEL_CONFIG";
        case RILC_REQ_WFC_DTMF_START: return "RIL_REQUEST_OEM_WFC_DTMF_START";
        case RILC_REQ_WFC_SET_VOWIFI_HO_THRESHOLD: return "RILC_REQ_WFC_SET_VOWIFI_HO_THRESHOLD";

        // Seceure Element
        case RILC_REQ_SE_OPEN_CHANNEL: return "RIL_REQUEST_OEM_SIM_OPEN_CHANNEL";
        case RILC_REQ_SE_TRANSMIT_APDU_LOGICAL: return "RIL_REQUEST_OEM_SIM_TRANSMIT_APDU_LOGICAL";
        case RILC_REQ_SE_TRANSMIT_APDU_BASIC: return "RIL_REQUEST_OEM_SIM_TRANSMIT_APDU_BASIC";
        case RILC_REQ_SE_CLOSE_CHANNEL: return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
        case RILC_REQ_SE_GET_ICC_ATR: return "RIL_REQUEST_SIM_GET_ATR";
        case RILC_REQ_SE_GET_CARD_PRESENT: return "RIL_REQUEST_OEM_SIM_PRESENT";

        /* eMBMS */
        case RILC_REQ_EMBMS_ENABLE_SERVICE: return "RIL_REQUEST_OEM_EMBMS_ENABLE_SERVICE";
        case RILC_REQ_EMBMS_DISABLE_SERVICE: return "RIL_REQUEST_OEM_EMBMS_DISABLE_SERVICE";
        case RILC_REQ_EMBMS_SET_SESSION: return "RIL_REQUEST_OEM_EMBMS_SET_SESSION";
        case RILC_REQ_EMBMS_GET_SESSION_LIST: return "RIL_REQUEST_OEM_EMBMS_GET_SESSION_LIST";
        case RILC_REQ_EMBMS_GET_SIGNAL_STRENGTH: return "RIL_REQUEST_OEM_EMBMS_GET_SIGNAL_STRENGTH";
        case RILC_REQ_EMBMS_GET_NETWORK_TIME: return "RIL_REQUEST_OEM_EMBMS_GET_NETWORK_TIME";
        case RILC_REQ_EMBMS_CHECK_AVAIABLE_EMBMS: return "RIL_REQUEST_OEM_EMBMS_CHECK_AVAIABLE_EMBMS";

        //P-SENSOR
        case RILC_REQ_PSENSOR_SET_STATUS: return "RIL_REQUEST_OEM_PSENSOR_SET_STATUS";

        // VSIM
        case RILC_REQ_VSIM_NOTIFICATION: return "RIL_REQUEST_OEM_VSIM_NOTIFICATION";
        case RILC_REQ_VSIM_OPERATION: return "RIL_REQEUST_OEM_VSIM_OPERATION";

        //SAR
        case RILC_REQ_SAR_SET_SAR_STATE: return "RIL_REQUEST_OEM_SAR_SET_STATE";
        case RILC_REQ_SAR_GET_SAR_STATE: return "RIL_REQUEST_OEM_SAR_GET_STATE";

        //SELFLOG
        case RILC_REQ_SET_SELFLOG: return "RIL_REQUEST_OEM_SET_SELFLOG";
        case RILC_REQ_GET_SELFLOG_STATUS: return "RIL_REQUEST_OEM_GET_SELFLOG_STATUS";
        // CP Sleep Log
        case RILC_REQ_SET_MODEM_LOG_DUMP: return "RIL_REQUEST_OEM_SET_MODEM_LOG_DUMP";

        case RILC_REQ_CANCEL_GET_AVAILABLE_NETWORK: return "RIL_REQUEST_OEM_CANCEL_AVAILABLE_NETWORKS";
        case RILC_REQ_SET_UICC_SUBSCRIPTION: return "RILC_REQ_SET_UICC_SUBSCRIPTION";

        case RILC_REQ_GET_RADIO_NODE: return "RIL_REQUEST_OEM_GET_RADIO_NODE";
        case RILC_REQ_SET_RADIO_NODE: return "RIL_REQUEST_OEM_SET_RADIO_NODE";
        case RILC_REQ_GET_PROVISION_UPDATE_REQUEST: return "RIL_REQUEST_OEM_GET_PROVISION_UPDATE_REQUEST";
        case RILC_REQ_SET_PROVISION_UPDATE_DONE_REQUEST: return "RIL_REQUEST_OEM_SET_PROVISION_UPDATE_DONE_REQUEST";
        case RILC_REQ_RADIO_CONFIG_RESET: return "RIL_REQUEST_OEM_RADIO_CONFIG_RESET";
        case RILC_REQ_VERIFY_MSL: return "RIL_REQUEST_OEM_GET_MSL_CODE";
        case RILC_REQ_GET_PLMN_NAME_FROM_SE13TABLE: return "RIL_REQUEST_OEM_GET_PLMN_NAME_FROM_SE13TABLE";
        case RILC_REQ_TS25TABLE_DUMP: return "RIL_REQUEST_OEM_TS25TABLE_DUMP";
        case RILC_REQ_MODEM_INFO: return "RIL_REQUEST_OEM_MODEM_INFO";
        case RILC_REQ_MODEM_RESET: return "RIL_REQUEST_OEM_MODEM_RESET";
        case RILC_REQ_SET_RTP_PKTLOSS_THRESHOLD: return "RIL_REQUEST_OEM_SET_RTP_PKTLOSS_THRESHOLD";
        case RILC_REQ_SWITCH_MODEM_FUNCTION: return "RIL_REQUEST_OEM_SWITCH_MODEM_FUNCTION";
        case RILC_REQ_SET_PDCP_DISCARD_TIMER: return "RIL_REQUEST_OEM_REQ_SET_PDCP_DISCARD_TIMER";
        case RILC_REQ_GET_CQI_INFO: return "RIL_REQUEST_OEM_GET_CQI_INFO";
        case RILC_REQ_SET_SAR_SETTING: return "RIL_REQUEST_OEM_SET_SAR_SETTING";
        case RILC_REQ_SET_IMS_TEST_MODE: return "RIL_REQUEST_OEM_SET_IMS_TEST_MODE";
        case RILC_REQ_SET_GMO_SWITCH: return "RIL_REQUEST_OEM_SET_GMO_SWITCH";
        case RILC_REQ_SET_TCS_FCI: return "RIL_REQUEST_OEM_SET_TCS_FCI";
        case RILC_REQ_GET_TCS_FCI: return "RIL_REQUEST_OEM_GET_TCS_FCI";
        case RILC_REQ_SET_CA_BANDWIDTH_FILTER: return "RILC_REQ_SET_CA_BANDWIDTH_FILTER";
        case RILC_REQ_ICC_DEPERSONALIZATION: return "RILC_REQ_ICC_DEPERSONALIZATION";
        case RILC_REQ_SET_ELEVATOR_SENSOR: return "RIL_REQUEST_OEM_SET_ELEVATOR_SENSOR";
        case RILC_REQ_SET_SELFLOG_PROFILE: return "RILC_REQ_SET_SELFLOG_PROFILE";
        case RILC_REQ_SET_FORBID_LTE_CELL: return "RILC_REQ_SET_FORBID_LTE_CELL";
        default: return "RIL_REQUEST_OEM_INVALID";
    }
}

static int convertRilcReqId2RilOemReqId(int rilcReqId) {
    int rilOemReqId = RIL_REQUEST_OEM_INVALID;
    switch (rilcReqId) {
        case RILC_REQ_SYSTEM_MODEM_DUMP: rilOemReqId = RIL_REQUEST_OEM_MODEM_DUMP; break;
        case RILC_REQ_MISC_SET_ENG_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_ENG_MODE; break;
        case RILC_REQ_MISC_SCREEN_LINE: rilOemReqId = RIL_REQUEST_OEM_SET_SCR_LINE; break;
        case RILC_REQ_MISC_DEBUG_TRACE: rilOemReqId = RIL_REQUEST_OEM_SET_DEBUG_TRACE; break;
        case RILC_REQ_MISC_SET_CARRIER_CONFIG: rilOemReqId = RIL_REQUEST_OEM_SET_CARRIER_CONFIG; break;
        case RILC_REQ_MISC_SET_ENG_STRING_INPUT: rilOemReqId = RIL_REQUEST_OEM_SET_ENG_STRING_INPUT; break;
        case RILC_REQ_MISC_APN_SETTINGS: rilOemReqId = RIL_REQUEST_OEM_APN_SETTINGS; break;
        case RILC_REQ_MISC_GET_MSL_CODE: rilOemReqId = RIL_REQUEST_OEM_GET_MSL_CODE; break;
        case RILC_REQ_MISC_SET_PIN_CONTROL: rilOemReqId = RIL_REQUEST_OEM_SET_PIN_CONTROL; break;
        case RILC_REQ_MISC_SET_PREFERRED_CALL_CAPA: rilOemReqId = RIL_REQUEST_OEM_SET_PREFERRED_CALL_CAPABILITY; break;
        case RILC_REQ_MISC_GET_PREFERRED_CALL_CAPA: rilOemReqId = RIL_REQUEST_OEM_GET_PREFERRED_CALL_CAPABILITY; break;
        case RILC_REQ_MISC_GET_MANUAL_BAND_MODE: rilOemReqId = RIL_REQUEST_OEM_GET_MANUAL_BAND_MODE; break;
        case RILC_REQ_MISC_SET_MANUAL_BAND_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_MANUAL_BAND_MODE; break;
        case RILC_REQ_MISC_GET_RF_DESENSE_MODE: rilOemReqId = RIL_REQUEST_OEM_GET_RF_DESENSE_MODE; break;
        case RILC_REQ_MISC_SET_RF_DESENSE_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_RF_DESENSE_MODE; break;
        case RILC_REQ_MISC_STORE_ADB_SERIAL_NUMBER: rilOemReqId = RIL_REQUEST_OEM_STORE_ADB_SERIAL_NUMBER; break;
        case RILC_REQ_MISC_READ_ADB_SERIAL_NUMBER: rilOemReqId = RIL_REQUEST_OEM_READ_ADB_SERIAL_NUMBER; break;
        case RILC_REQ_GET_MANUAL_RAT_MODE: rilOemReqId = RIL_REQUEST_OEM_GET_MANUAL_RAT_MODE; break;
        case RILC_REQ_SET_MANUAL_RAT_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_MANUAL_RAT_MODE; break;
        case RILC_REQ_GET_FREQUENCY_LOCK: rilOemReqId = RIL_REQUEST_OEM_GET_FREQUENCY_LOCK; break;
        case RILC_REQ_SET_FREQUENCY_LOCK: rilOemReqId = RIL_REQUEST_OEM_SET_FREQUENCY_LOCK; break;
        case RILC_REQ_SET_ENDC_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_ENDC_MODE; break;
        case RILC_REQ_GET_ENDC_MODE: rilOemReqId = RIL_REQUEST_OEM_GET_ENDC_MODE; break;
        case RILC_REQ_SCAN_RSSI: rilOemReqId = RIL_REQUEST_OEM_SCAN_RSSI; break;
        case RILC_REQ_FORWARDING_AT_COMMAND: rilOemReqId = RIL_REQUEST_OEM_FORWARDING_AT_COMMAND; break;
        case RILC_REQ_AUDIO_SET_MUTE: rilOemReqId = RIL_REQUEST_SET_MUTE; break;
        case RILC_REQ_AUDIO_GET_MUTE: rilOemReqId = RIL_REQUEST_GET_MUTE; break;
        case RILC_REQ_AUDIO_SET_VOLUME: rilOemReqId = RIL_REQUEST_OEM_VOLUME_SET; break;
        case RILC_REQ_AUDIO_GET_VOLUME: rilOemReqId = RIL_REQUEST_OEM_VOLUME_GET; break;
        case RILC_REQ_AUDIO_SET_PATH: rilOemReqId = RIL_REQUEST_OEM_AUDIO_PATH_SET; break;
        case RILC_REQ_AUDIO_GET_PATH: rilOemReqId = RIL_REQUEST_OEM_AUDIO_PATH_GET; break;
        case RILC_REQ_AUDIO_SET_MIC: rilOemReqId = RIL_REQUEST_OEM_MICROPHONE_SET; break;
        case RILC_REQ_AUDIO_GET_MIC: rilOemReqId = RIL_REQUEST_OEM_MICROPHONE_GET; break;
        case RILC_REQ_AUDIO_SET_AUDIO_CLOCK: rilOemReqId = RIL_REQUEST_OEM_AUDIO_CLOCK_SET; break;
        case RILC_REQ_AUDIO_SET_AUDIO_LOOPBACK: rilOemReqId = RIL_REQUEST_OEM_AUDIO_LOOPBACK_SET; break;
        case RILC_REQ_AUDIO_SET_TTY_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_TTY_MODE; break;
        case RILC_REQ_GET_AVAILABLE_NETWORKS: rilOemReqId = RIL_REQUEST_OEM_GET_AVAILABLE_NETWORKS; break;
        case RILC_REQ_GET_FREQUENCY_INFO: rilOemReqId = RIL_REQUEST_OEM_GET_FREQUENCY_INFO; break;

        case RILC_REQ_IMS_SET_CONFIGURATION: rilOemReqId = RIL_REQUEST_OEM_IMS_SET_CONFIGURATION; break;
        case RILC_REQ_IMS_GET_CONFIGURATION: rilOemReqId = RIL_REQUEST_OEM_IMS_GET_CONFIGURATION; break;
        case RILC_REQ_IMS_SIM_AUTH: rilOemReqId = RIL_REQUEST_OEM_IMS_SIM_AUTH; break;
        case RILC_REQ_IMS_SET_EMERGENCY_CALL_STATUS: rilOemReqId = RIL_REQUEST_OEM_IMS_SET_EMERGENCY_CALL_STATUS; break;
        case RILC_REQ_IMS_SET_SRVCC_CALL_LIST: rilOemReqId = RIL_REQUEST_OEM_IMS_SET_SRVCC_CALL_LIST; break;
        case RILC_REQ_IMS_GET_GBA_AUTH: rilOemReqId = RIL_REQUEST_OEM_IMS_GET_GBA_AUTH; break;
        case RILC_REQ_IMS_SIM_IO: rilOemReqId = RIL_REQUEST_OEM_IMS_SIM_IO; break;
        case RILC_REQ_NET_GET_IMS_SUPPORT_SERVICE: rilOemReqId = RIL_REQUEST_OEM_GET_IMS_SUPPORT_SERVICE; break;

        /* GPS */
        case RILC_REQ_GPS_SET_FREQUENCY_AIDING: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_FREQUENCY_AIDING; break;
        case RILC_REQ_GPS_GET_LPP_SUPL_REQ_ECID_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_GET_LPP_SUPL_REQ_ECID_INFO; break;
        case RILC_REQ_GPS_SET_RRLP_SUPL_REQ_ECID_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_RRLP_SUPL_REQ_ECID_INFO; break;
        case RILC_REQ_GPS_MO_LOCATION_REQUEST: rilOemReqId = RIL_REQUEST_OEM_GPS_MO_LOCATION_REQUEST; break;
        case RILC_REQ_GPS_GET_LPP_REQ_SERVING_CELL_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_GET_LPP_REQ_SERVING_CELL_INFO; break;
        case RILC_REQ_GPS_SET_SUPL_NI_READY: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_SUPL_NI_READY; break;
        case RILC_REQ_GPS_MEASURE_POS_RSP : rilOemReqId = RIL_REQUEST_OEM_GPS_MEASURE_POS_RSP; break;
        case RILC_REQ_GPS_RELEASE_GPS : rilOemReqId = RIL_REQUEST_OEM_GPS_RELEASE_GPS; break;
        case RILC_REQ_GPS_MT_LOCATION_REQUEST: rilOemReqId = RIL_REQUEST_OEM_GPS_MT_LOCATION_REQUEST; break;
        case RILC_REQ_GPS_LPP_PROVIDE_CAPABILITIES: rilOemReqId = RIL_REQUEST_OEM_GPS_LPP_PROVIDE_CAPABILITIES; break;
        case RILC_REQ_GPS_LPP_REQUEST_ASSIST_DATA: rilOemReqId = RIL_REQUEST_OEM_GPS_LPP_REQUEST_ASSIST_DATA; break;
        case RILC_REQ_GPS_LPP_PROVIDE_LOCATION_INFO: rilOemReqId =  RIL_REQUEST_OEM_GPS_LPP_PROVIDE_LOCATION_INFO; break;
        case RILC_REQ_GPS_LPP_GPS_ERROR_IND: rilOemReqId = RIL_REQUEST_OEM_GPS_LPP_GPS_ERROR_IND; break;
        case RILC_REQ_GPS_SUPL_LPP_DATA_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_SUPL_LPP_DATA_INFO; break;
        case RILC_REQ_GPS_SUPL_NI_MESSAGE: rilOemReqId = RIL_REQUEST_OEM_GPS_SUPL_NI_MESSAGE; break;
        case RILC_REQ_GPS_SET_GANSS_MEAS_POS_RSP: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_GANSS_MEAS_POS_RSP; break;
        case RILC_REQ_GPS_SET_GPS_LOCK_MODE: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_GPS_LOCK_MODE; break;
        case RILC_REQ_GPS_GET_REFERENCE_LOCATION: rilOemReqId = RIL_REQUEST_OEM_GPS_GET_REFERENCE_LOCATION; break;
        case RILC_REQ_GPS_SET_PSEUDO_RANGE_MEASUREMENTS: rilOemReqId = RIL_REQUEST_OEM_GPS_SET_PSEUDO_RANGE_MEASUREMENTS; break;
        case RILC_REQ_GPS_GET_CDMA_PRECISE_TIME_AIDING_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_GET_CDMA_PRECISE_TIME_AIDING_INFO; break;
        case RILC_REQ_GPS_GANSS_AP_POS_CAP_RSP: rilOemReqId = RIL_REQUEST_OEM_GPS_GANSS_AP_POS_CAP_RSP; break;
        case RILC_REQ_GPS_GET_GSM_EXT_INFO_MSG: rilOemReqId = RIL_REQUEST_OEM_GPS_GET_GSM_EXT_INFO_MSG; break;
        case RILC_REQ_GPS_CONTROL_PLANE_ENABLE: rilOemReqId = RIL_REQUEST_OEM_GPS_CONTROL_PLANE_ENABLE; break;
        case RILC_REQ_GPS_GNSS_LPP_PROFILE_SET: rilOemReqId = RIL_REQUEST_OEM_GPS_GNSS_LPP_PROFILE_SET; break;
        case RILC_REQ_GPS_RETRIEVE_LOC_INFO: rilOemReqId = RIL_REQUEST_OEM_GPS_RETRIEVE_LOC_INFO; break;
        case RILC_REQ_GPS_CDMA_FREQ_AIDING: rilOemReqId = RIL_REQUEST_OEM_GPS_CDMA_FREQ_AIDING; break;

        case RILC_REQ_WLAN_GET_IMSI: rilOemReqId = RIL_REQUEST_GET_IMSI; break;
        case RILC_REQ_WLAN_SIM_AUTHENTICATE: rilOemReqId = RIL_REQUEST_OEM_SIM_AUTHENTICATION; break;
        case RILC_REQ_IF_EXECUTE_AM: rilOemReqId = RIL_REQUEST_OEM_IF_EXECUTE_AM; break;

        case RILC_REQ_AIMS_DIAL: rilOemReqId = RIL_REQUEST_OEM_AIMS_DIAL; break;
        case RILC_REQ_AIMS_ANSWER: rilOemReqId = RIL_REQUEST_OEM_AIMS_ANSWER; break;
        case RILC_REQ_AIMS_HANGUP: rilOemReqId = RIL_REQUEST_OEM_AIMS_HANGUP; break;
        case RILC_REQ_AIMS_DEREGISTRATION: rilOemReqId = RIL_REQUEST_OEM_AIMS_DEREGISTRATION; break;
        case RILC_REQ_AIMS_HIDDEN_MENU: rilOemReqId = RIL_REQUEST_OEM_AIMS_HIDDEN_MENU; break;
        case RILC_REQ_AIMS_ADD_PDN_INFO: rilOemReqId = RIL_REQUEST_OEM_AIMS_ADD_PDN_INFO; break;
        case RILC_REQ_AIMS_CALL_MANAGE: rilOemReqId = RIL_REQUEST_OEM_AIMS_CALL_MANAGE; break;
        case RILC_REQ_AIMS_SEND_DTMF: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_DTMF; break;
        case RILC_REQ_AIMS_SET_FRAME_TIME: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_FRAME_TIME; break;
        case RILC_REQ_AIMS_GET_FRAME_TIME: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_FRAME_TIME; break;
        case RILC_REQ_AIMS_CALL_MODIFY: rilOemReqId = RIL_REQUEST_OEM_AIMS_CALL_MODIFY; break;
        case RILC_REQ_AIMS_RESPONSE_CALL_MODIFY: rilOemReqId = RIL_REQUEST_OEM_AIMS_RESPONSE_CALL_MODIFY; break;
        case RILC_REQ_AIMS_TIME_INFO: rilOemReqId = RIL_REQUEST_OEM_AIMS_TIME_INFO; break;
        case RILC_REQ_AIMS_CONF_CALL_ADD_REMOVE_USER: rilOemReqId = RIL_REQUEST_OEM_AIMS_CONF_CALL_ADD_REMOVE_USER; break;
        case RILC_REQ_AIMS_ENHANCED_CONF_CALL: rilOemReqId = RIL_REQUEST_OEM_AIMS_ENHANCED_CONF_CALL; break;
        case RILC_REQ_AIMS_GET_CALL_FORWARD_STATUS: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_CALL_FORWARD_STATUS; break;
        case RILC_REQ_AIMS_SET_CALL_FORWARD_STATUS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_CALL_FORWARD_STATUS; break;
        case RILC_REQ_AIMS_GET_CALL_WAITING: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_CALL_WAITING; break;
        case RILC_REQ_AIMS_SET_CALL_WAITING: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_CALL_WAITING; break;
        case RILC_REQ_AIMS_GET_CALL_BARRING: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_CALL_BARRING; break;
        case RILC_REQ_AIMS_SET_CALL_BARRING: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_CALL_BARRING; break;
        case RILC_REQ_AIMS_SEND_SMS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_SMS; break;
        case RILC_REQ_AIMS_SEND_EXPECT_MORE: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_EXPECT_MORE; break;
        case RILC_REQ_AIMS_SEND_SMS_ACK: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_SMS_ACK; break;
        case RILC_REQ_AIMS_SEND_ACK_INCOMING_SMS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_ACK_INCOMING_SMS; break;
        case RILC_REQ_AIMS_CHG_BARRING_PWD: rilOemReqId = RIL_REQUEST_OEM_AIMS_CHG_BARRING_PWD; break;
        case RILC_REQ_AIMS_SEND_USSD_INFO: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_USSD_INFO; break;
        case RILC_REQ_AIMS_GET_PRESENTATION_SETTINGS: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_PRESENTATION_SETTINGS; break;
        case RILC_REQ_AIMS_SET_PRESENTATION_SETTINGS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_PRESENTATION_SETTINGS; break;
        case RILC_REQ_AIMS_SET_SELF_CAPABILITY: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_SELF_CAPABILITY; break;
        case RILC_REQ_AIMS_HO_TO_WIFI_READY: rilOemReqId = RIL_REQUEST_OEM_AIMS_HO_TO_WIFI_READY; break;
        case RILC_REQ_AIMS_HO_TO_WIFI_CANCEL_IND: rilOemReqId = RIL_REQUEST_OEM_AIMS_HO_TO_WIFI_CANCEL_IND; break;
        case RILC_REQ_AIMS_HO_PAYLOAD_IND: rilOemReqId = RIL_REQUEST_OEM_AIMS_HO_PAYLOAD_IND; break;
        case RILC_REQ_AIMS_HO_TO_3GPP: rilOemReqId = RIL_REQUEST_OEM_AIMS_HO_TO_3GPP; break;
        case RILC_REQ_AIMS_SEND_ACK_INCOMING_CDMA_SMS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SEND_ACK_INCOMING_CDMA_SMS; break;
        case RILC_REQ_AIMS_MEDIA_STATE_IND: rilOemReqId = RIL_REQUEST_OEM_AIMS_MEDIA_STATE_IND; break;
        case RILC_REQ_AIMS_DEL_PDN_INFO: rilOemReqId = RIL_REQUEST_OEM_AIMS_DEL_PDN_INFO; break;
        case RILC_REQ_AIMS_STACK_START_REQ: rilOemReqId = RIL_REQUEST_OEM_AIMS_STACK_START_REQ; break;
        case RILC_REQ_AIMS_STACK_STOP_REQ: rilOemReqId = RIL_REQUEST_OEM_AIMS_STACK_STOP_REQ; break;
        case RILC_REQ_AIMS_XCAPM_START_REQ: rilOemReqId = RIL_REQUEST_OEM_AIMS_XCAPM_START_REQ; break;
        case RILC_REQ_AIMS_XCAPM_STOP_REQ: rilOemReqId = RIL_REQUEST_OEM_AIMS_XCAPM_STOP_REQ; break;
        case RILC_REQ_AIMS_RTT_SEND_TEXT: rilOemReqId = RIL_REQUEST_OEM_AIMS_RTT_SEND_TEXT; break;
        case RILC_REQ_AIMS_EXIT_EMERGENCY_CB_MODE: rilOemReqId = RIL_REQUEST_OEM_AIMS_EXIT_EMERGENCY_CB_MODE; break;
        case RILC_REQ_AIMS_SET_GEO_LOCATION_INFO: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_GEO_LOCATION_INFO; break;
        case RILC_REQ_AIMS_CDMA_SEND_SMS: rilOemReqId = RIL_REQUEST_OEM_AIMS_CDMA_SEND_SMS; break;
        case RILC_REQ_AIMS_RCS_MULTI_FRAME: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_MULTI_FRAME; break;
        case RILC_REQ_AIMS_RCS_CHAT: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_CHAT; break;
        case RILC_REQ_AIMS_RCS_GROUP_CHAT: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_GROUP_CHAT; break;
        case RILC_REQ_AIMS_RCS_OFFLINE_MODE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_OFFLINE_MODE; break;
        case RILC_REQ_AIMS_RCS_FILE_TRANSFER: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_FILE_TRANSFER; break;
        case RILC_REQ_AIMS_RCS_COMMON_MESSAGE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_COMMON_MESSAGE; break;
        case RILC_REQ_AIMS_RCS_CONTENT_SHARE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_CONTENT_SHARE; break;
        case RILC_REQ_AIMS_RCS_PRESENCE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_PRESENCE; break;
        case RILC_REQ_AIMS_XCAP_MANAGE: rilOemReqId = RIL_REQUEST_OEM_AIMS_XCAP_MANAGE; break;
        case RILC_REQ_AIMS_RCS_CONFIG_MANAGE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_CONFIG_MANAGE; break;
        case RILC_REQ_AIMS_RCS_TLS_MANAGE: rilOemReqId = RIL_REQUEST_OEM_AIMS_RCS_TLS_MANAGE; break;
        case RILC_REQ_AIMS_SET_PDN_EST_STATUS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_PDN_EST_STATUS; break;
        case RILC_REQ_AIMS_SET_HIDDEN_MENU_ITEM: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_HIDDEN_MENU_ITEM; break;
        case RILC_REQ_AIMS_GET_HIDDEN_MENU_ITEM: rilOemReqId = RIL_REQUEST_OEM_AIMS_GET_HIDDEN_MENU_ITEM; break;
        case RILC_REQ_AIMS_SET_RTP_RX_STATISTICS: rilOemReqId = RIL_REQUEST_OEM_AIMS_SET_RTP_RX_STATISTICS; break;

        case RILC_REQ_WFC_MEDIA_CHANNEL_CONFIG: rilOemReqId = RIL_REQUEST_OEM_WFC_MEDIA_CHANNEL_CONFIG; break;
        case RILC_REQ_WFC_DTMF_START: rilOemReqId = RIL_REQUEST_OEM_WFC_DTMF_START; break;
        case RILC_REQ_WFC_SET_VOWIFI_HO_THRESHOLD: rilOemReqId = RIL_REQUEST_OEM_WFC_SET_VOWIFI_HO_THRESHOLD; break;

        // Seceure Element
        case RILC_REQ_SE_OPEN_CHANNEL: rilOemReqId = RIL_REQUEST_OEM_SIM_OPEN_CHANNEL; break;
        case RILC_REQ_SE_TRANSMIT_APDU_LOGICAL: rilOemReqId = RIL_REQUEST_OEM_SIM_TRANSMIT_APDU_LOGICAL; break;
        case RILC_REQ_SE_TRANSMIT_APDU_BASIC: rilOemReqId = RIL_REQUEST_OEM_SIM_TRANSMIT_APDU_BASIC; break;
        case RILC_REQ_SE_CLOSE_CHANNEL: rilOemReqId = RIL_REQUEST_SIM_CLOSE_CHANNEL; break;
        case RILC_REQ_SE_GET_ICC_ATR: rilOemReqId = RIL_REQUEST_SIM_GET_ATR; break;
        case RILC_REQ_SE_GET_CARD_PRESENT: rilOemReqId = RIL_REQUEST_OEM_SIM_PRESENT; break;

        /* eMBMS */
        case RILC_REQ_EMBMS_ENABLE_SERVICE: rilOemReqId = RIL_REQUEST_OEM_EMBMS_ENABLE_SERVICE; break;
        case RILC_REQ_EMBMS_DISABLE_SERVICE: rilOemReqId = RIL_REQUEST_OEM_EMBMS_DISABLE_SERVICE; break;
        case RILC_REQ_EMBMS_SET_SESSION: rilOemReqId = RIL_REQUEST_OEM_EMBMS_SET_SESSION; break;
        case RILC_REQ_EMBMS_GET_SESSION_LIST: rilOemReqId = RIL_REQUEST_OEM_EMBMS_GET_SESSION_LIST; break;
        case RILC_REQ_EMBMS_GET_SIGNAL_STRENGTH: rilOemReqId = RIL_REQUEST_OEM_EMBMS_GET_SIGNAL_STRENGTH; break;
        case RILC_REQ_EMBMS_GET_NETWORK_TIME: rilOemReqId = RIL_REQUEST_OEM_EMBMS_GET_NETWORK_TIME; break;
        case RILC_REQ_EMBMS_CHECK_AVAIABLE_EMBMS: rilOemReqId = RIL_REQUEST_OEM_EMBMS_CHECK_AVAIABLE_EMBMS; break;

        // P-Sensor
        case RILC_REQ_PSENSOR_SET_STATUS: rilOemReqId = RIL_REQUEST_OEM_PSENSOR_SET_STATUS; break;

        // VSIM
        case RILC_REQ_VSIM_NOTIFICATION: rilOemReqId = RIL_REQUEST_OEM_VSIM_NOTIFICATION; break;
        case RILC_REQ_VSIM_OPERATION: rilOemReqId = RIL_REQUEST_OEM_VSIM_OPERATION; break;

        // SAR
        case RILC_REQ_SAR_SET_SAR_STATE: rilOemReqId = RIL_REQUEST_OEM_SAR_SET_STATE; break;
        case RILC_REQ_SAR_GET_SAR_STATE: rilOemReqId = RIL_REQUEST_OEM_SAR_GET_STATE; break;

        //SELFLOG
        case RILC_REQ_SET_SELFLOG: rilOemReqId = RIL_REQUEST_OEM_SET_SELFLOG; break;
        case RILC_REQ_GET_SELFLOG_STATUS: rilOemReqId = RIL_REQUEST_OEM_GET_SELFLOG_STATUS; break;
        // CP Sleep Log
        case RILC_REQ_SET_MODEM_LOG_DUMP: rilOemReqId = RIL_REQUEST_OEM_SET_MODEM_LOG_DUMP; break;

        case RILC_REQ_CANCEL_GET_AVAILABLE_NETWORK: rilOemReqId = RIL_REQUEST_OEM_CANCEL_AVAILABLE_NETWORKS; break;
        case RILC_REQ_SET_UICC_SUBSCRIPTION: rilOemReqId = RIL_REQUEST_OEM_SET_UICC_SUBSCRIPTION; break;

        // OEM2
        case RILC_REQ_GET_RADIO_NODE: rilOemReqId = RIL_REQUEST_OEM_GET_RADIO_NODE; break;
        case RILC_REQ_SET_RADIO_NODE: rilOemReqId = RIL_REQUEST_OEM_SET_RADIO_NODE; break;
        case RILC_REQ_GET_PROVISION_UPDATE_REQUEST: rilOemReqId = RIL_REQUEST_OEM_GET_PROVISION_UPDATE_REQUEST; break;
        case RILC_REQ_SET_PROVISION_UPDATE_DONE_REQUEST: rilOemReqId = RIL_REQUEST_OEM_SET_PROVISION_UPDATE_DONE_REQUEST; break;
        case RILC_REQ_RADIO_CONFIG_RESET: rilOemReqId = RIL_REQUEST_OEM_RADIO_CONFIG_RESET; break;
        case RILC_REQ_VERIFY_MSL: rilOemReqId = RIL_REQUEST_OEM_GET_MSL_CODE; break;
        case RILC_REQ_GET_PLMN_NAME_FROM_SE13TABLE: rilOemReqId = RIL_REQUEST_OEM_GET_PLMN_NAME_FROM_SE13TABLE; break;
        case RILC_REQ_TS25TABLE_DUMP: rilOemReqId = RIL_REQUEST_OEM_TS25TABLE_DUMP; break;
        case RILC_REQ_SET_CA_BANDWIDTH_FILTER: rilOemReqId = RIL_REQUEST_OEM_SET_CA_BANDWIDTH_FILTER; break;
        case RILC_REQ_ICC_DEPERSONALIZATION: rilOemReqId = RIL_REQUEST_OEM_ICC_DEPERSONALIZATION; break;

        // OEM5
        case RILC_REQ_MODEM_INFO: rilOemReqId = RIL_REQUEST_OEM_MODEM_INFO; break;
        case RILC_REQ_MODEM_RESET: rilOemReqId = RIL_REQUEST_OEM_MODEM_RESET; break;
        case RILC_REQ_SET_RTP_PKTLOSS_THRESHOLD: rilOemReqId = RIL_REQUEST_OEM_SET_RTP_PKTLOSS_THRESHOLD; break;
        case RILC_REQ_SWITCH_MODEM_FUNCTION: rilOemReqId = RIL_REQUEST_OEM_SWITCH_MODEM_FUNCTION; break;
        case RILC_REQ_SET_PDCP_DISCARD_TIMER: rilOemReqId = RIL_REQUEST_OEM_REQ_SET_PDCP_DISCARD_TIMER; break;
        case RILC_REQ_GET_CQI_INFO: rilOemReqId = RIL_REQUEST_OEM_GET_CQI_INFO; break;
        case RILC_REQ_SET_SAR_SETTING: rilOemReqId = RIL_REQUEST_OEM_SET_SAR_SETTING; break;
        case RILC_REQ_SET_IMS_TEST_MODE: rilOemReqId = RIL_REQUEST_OEM_SET_IMS_TEST_MODE; break;
        case RILC_REQ_SET_GMO_SWITCH: rilOemReqId = RIL_REQUEST_OEM_SET_GMO_SWITCH; break;
        case RILC_REQ_SET_TCS_FCI: rilOemReqId = RIL_REQUEST_OEM_SET_TCS_FCI; break;
        case RILC_REQ_GET_TCS_FCI: rilOemReqId = RIL_REQUEST_OEM_GET_TCS_FCI; break;
        case RILC_REQ_SET_ELEVATOR_SENSOR: rilOemReqId = RIL_REQUEST_OEM_SET_ELEVATOR_SENSOR; break;
        case RILC_REQ_SET_SELFLOG_PROFILE: rilOemReqId = RIL_REQUEST_OEM_SET_SELFLOG_PROFILE; break;
        case RILC_REQ_SET_FORBID_LTE_CELL: rilOemReqId = RIL_REQUEST_OEM_SET_FORBID_LTE_CELL; break;
    }
    return rilOemReqId;
}


static int convertRilOemUnsolRspId2RilcRespId(int unsolResponse) {
    int rilcUnsolRspId = RILC_UNSOL_NOT_SUPPORTED;
    /* check response */
    switch (unsolResponse) {
        case RIL_UNSOL_OEM_IMS_CONFIGURATION: rilcUnsolRspId = RILC_UNSOL_IMS_CONFIGURATION; break;
        case RIL_UNSOL_OEM_IMS_DEDICATED_PDN_INFO: rilcUnsolRspId = RILC_UNSOL_IMS_DEDICATED_PDN_INFO; break;
        case RIL_UNSOL_OEM_IMS_EMERGENCY_ACT_INFO: rilcUnsolRspId = RILC_UNSOL_IMS_EMERGENCY_ACT_INFO; break;
        case RIL_UNSOL_OEM_IMS_SET_SRVCC_INFO: rilcUnsolRspId = RILC_UNSOL_IMS_SRVCC_HO; break;
        case RIL_UNSOL_OEM_IMS_EMERGENCY_CALL_LIST: rilcUnsolRspId = RILC_UNSOL_IMS_EMERGENCY_CALL_LIST; break;
        case RIL_UNSOL_OEM_IMS_SUPPORT_SERVICE: rilcUnsolRspId = RILC_UNSOL_IMS_SUPPORT_SERVICE; break;
        case RIL_UNSOL_OEM_IMS_OPEN_CARRIER_INFO: rilcUnsolRspId = RILC_UNSOL_IMS_OPEN_CARRIER_INFO; break;
        case RIL_UNSOL_OEM_SCAN_RSSI_RESULT: rilcUnsolRspId = RILC_UNSOL_SCAN_RSSI_RESULT; break;
        case RIL_UNSOL_OEM_FORWARDING_AT_COMMAND: rilcUnsolRspId = RILC_UNSOL_FORWARDING_AT_COMMAND; break;
        case RIL_UNSOL_WB_AMR_REPORT_IND: rilcUnsolRspId = RILC_UNSOL_WB_AMR_REPORT; break;

        case RIL_UNSOL_OEM_GPS_MEASURE_POS_REQ: rilcUnsolRspId = RILC_UNSOL_GPS_MEASURE_POS_REQ; break;
        case RIL_UNSOL_OEM_GPS_ASSIST_DATA: rilcUnsolRspId = RILC_UNSOL_GPS_ASSIST_DATA; break;
        case RIL_UNSOL_OEM_GPS_RELEASE_GPS: rilcUnsolRspId = RILC_UNSOL_GPS_RELEASE_GPS; break;
        case RIL_UNSOL_OEM_GPS_MT_LOCATION_REQUEST: rilcUnsolRspId = RILC_UNSOL_GPS_MT_LOCATION_REQUEST; break;
        case RIL_UNSOL_OEM_GPS_RESET_GPS_ASSIST_DATA: rilcUnsolRspId = RILC_UNSOL_GPS_RESET_GPS_ASSIST_DATA; break;
        case RIL_UNSOL_OEM_GPS_LPP_REQUEST_CAPABILITIES: rilcUnsolRspId = RILC_UNSOL_GPS_LPP_REQUEST_CAPABILITIES; break;
        case RIL_UNSOL_OEM_GPS_LPP_PROVIDE_ASSIST_DATA: rilcUnsolRspId = RILC_UNSOL_GPS_LPP_PROVIDE_ASSIST_DATA; break;
        case RIL_UNSOL_OEM_GPS_LPP_REQUEST_LOCATION_INFO: rilcUnsolRspId = RILC_UNSOL_GPS_LPP_REQUEST_LOCATION_INFO; break;
        case RIL_UNSOL_OEM_GPS_LPP_GPS_ERROR_IND: rilcUnsolRspId = RILC_UNSOL_GPS_LPP_GPS_ERROR_IND; break;
        case RIL_UNSOL_OEM_GPS_SUPL_LPP_DATA_INFO: rilcUnsolRspId = RILC_UNSOL_GPS_SUPL_LPP_DATA_INFO; break;
        case RIL_UNSOL_OEM_GPS_SUPL_NI_MESSAGE: rilcUnsolRspId = RILC_UNSOL_GPS_SUPL_NI_MESSAGE; break;
        case RIL_UNSOL_OEM_GPS_3GPP_SEND_GANSS_ASSIT_DATA: rilcUnsolRspId = RILC_UNSOL_GPS_3GPP_SEND_GANSS_ASSIT_DATA; break;
        case RIL_UNSOL_OEM_GPS_GANSS_MEAS_POS_MSG: rilcUnsolRspId = RILC_UNSOL_GPS_GANSS_MEAS_POS_MSG; break;
        case RIL_UNSOL_OEM_GPS_CDMA_GPS_POWER_ON: rilcUnsolRspId = RILC_UNSOL_GPS_CDMA_GPS_POWER_ON; break;
        case RIL_UNSOL_OEM_GPS_CDMA_SEND_ACQUSITION_ASSIT_DATA: rilcUnsolRspId = RILC_UNSOL_GPS_CDMA_SEND_ACQUSITION_ASSIT_DATA; break;
        case RIL_UNSOL_OEM_GPS_CDMA_SESSION_CANCELLATION: rilcUnsolRspId = RILC_UNSOL_GPS_CDMA_SESSION_CANCELLATION; break;
        case RIL_UNSOL_OEM_GPS_GANSS_AP_POS_CAP_REQ: rilcUnsolRspId = RILC_UNSOL_GPS_GANSS_AP_POS_CAP_REQ; break;
        case RIL_UNSOL_OEM_GPS_SUPL_NI_READY: rilcUnsolRspId = RILC_UNSOL_GPS_SUPL_NI_READY; break;
        case RIL_UNSOL_OEM_GPS_START_MDT_LOC: rilcUnsolRspId = RILC_UNSOL_GPS_START_MDT_LOC; break;
        case RIL_UNSOL_OEM_GPS_LPP_UPDATE_UE_LOC_INFO: rilcUnsolRspId = RILC_UNSOL_GPS_LPP_UPDATE_UE_LOC_INFO; break;
        case RIL_UNSOL_OEM_GPS_LOCK_MODE: rilcUnsolRspId = RILC_UNSOL_GPS_LOCK_MODE; break;

        case RIL_UNSOL_OEM_DISPLAY_ENG_MODE: rilcUnsolRspId = RILC_UNSOL_DISPLAY_ENG_MODE; break;
        case RIL_UNSOL_OEM_AM: rilcUnsolRspId = RILC_UNSOL_AM; break;
        case RIL_UNSOL_OEM_PIN_CONTROL: rilcUnsolRspId = RILC_UNSOL_PIN_CONTROL; break;

        case RIL_UNSOL_OEM_AIMS_CALL_RING: rilcUnsolRspId = RILC_UNSOL_AIMS_CALL_RING; break;
        case RIL_UNSOL_OEM_AIMS_CALL_STATUS: rilcUnsolRspId = RILC_UNSOL_AIMS_CALL_STATUS; break;
        case RIL_UNSOL_OEM_AIMS_REGISTRATION: rilcUnsolRspId = RILC_UNSOL_AIMS_REGISTRATION; break;
        case RIL_UNSOL_OEM_AIMS_CALL_MODIFY: rilcUnsolRspId = RILC_UNSOL_AIMS_CALL_MODIFY; break;
        case RIL_UNSOL_OEM_AIMS_FRAME_TIME: rilcUnsolRspId = RILC_UNSOL_AIMS_FRAME_TIME; break;
        case RIL_UNSOL_OEM_AIMS_SUPP_SVC_NOTIFICATION: rilcUnsolRspId = RILC_UNSOL_AIMS_SUPP_SVC_NOTIFICATION; break;
        case RIL_UNSOL_OEM_AIMS_NEW_SMS: rilcUnsolRspId = RILC_UNSOL_AIMS_NEW_SMS; break;
        case RIL_UNSOL_OEM_AIMS_NEW_SMS_STATUS_REPORT: rilcUnsolRspId = RILC_UNSOL_AIMS_NEW_SMS_STATUS_REPORT; break;
        case RIL_UNSOL_OEM_AIMS_ON_USSD: rilcUnsolRspId = RILC_UNSOL_AIMS_ON_USSD; break;
        case RIL_UNSOL_OEM_AIMS_CONFERENCE_CALL_EVENT: rilcUnsolRspId = RILC_UNSOL_AIMS_CONFERENCE_CALL_EVENT; break;
        case RIL_UNSOL_OEM_AIMS_PAYLOAD_INFO: rilcUnsolRspId = RILC_UNSOL_AIMS_HO_PAYLOAD; break;
        case RIL_UNSOL_OEM_AIMS_VOWIFI_HO_CALL_INFO: rilcUnsolRspId = RILC_UNSOL_AIMS_VOWIFI_HO_CALL_INFO; break;
        case RIL_UNSOL_OEM_AIMS_NEW_CDMA_SMS: rilcUnsolRspId = RILC_UNSOL_AIMS_NEW_CDMA_SMS; break;
        case RIL_UNSOL_OEM_AIMS_RINGBACK_TONE: rilcUnsolRspId = RILC_UNSOL_AUDIO_RINGBACK; break;
        case RIL_UNSOL_OEM_RINGBACK_TONE_BY_NETWORK: rilcUnsolRspId = RILC_UNSOL_AUDIO_RINGBACK_BY_NETWORK; break;

        case RIL_UNSOL_OEM_AIMS_CALL_MANAGE: rilcUnsolRspId = RILC_UNSOL_AIMS_CALL_MANAGE; break;
        case RIL_UNSOL_OEM_AIMS_CONF_CALL_ADD_REMOVE_USER: rilcUnsolRspId = RILC_UNSOL_AIMS_CONF_CALL_ADD_REMOVE_USER; break;
        case RIL_UNSOL_OEM_AIMS_ENHANCED_CONF_CALL: rilcUnsolRspId = RILC_UNSOL_AIMS_ENHANCED_CONF_CALL; break;
        case RIL_UNSOL_OEM_AIMS_CALL_MODIFY_RSP: rilcUnsolRspId = RILC_UNSOL_AIMS_CALL_MODIFY_RSP; break;
        case RIL_UNSOL_OEM_AIMS_DTMF_EVENT: rilcUnsolRspId = RILC_UNSOL_AIMS_DTMF_EVENT; break;
        case RIL_UNSOL_OEM_AIMS_RTT_NEW_TEXT: rilcUnsolRspId = RILC_UNSOL_AIMS_RTT_NEW_TEXT; break;
        case RIL_UNSOL_OEM_AIMS_RTT_FAIL_SENDING_TEXT: rilcUnsolRspId = RILC_UNSOL_AIMS_RTT_FAIL_SENDING_TEXT; break;
        case RIL_UNSOL_OEM_AIMS_EXIT_EMERGENCY_CB_MODE: rilcUnsolRspId = RILC_UNSOL_AIMS_EXIT_EMERGENCY_CB_MODE; break;
        case RIL_UNSOL_OEM_AIMS_DIALOG_INFO: rilcUnsolRspId = RILC_UNSOL_AIMS_DIALOG_INFO; break;
        case RIL_UNSOL_OEM_AIMS_RCS_MULTI_FRAME: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_MULTI_FRAME; break;
        case RIL_UNSOL_OEM_AIMS_RCS_CHAT: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_CHAT; break;
        case RIL_UNSOL_OEM_AIMS_RCS_GROUP_CHAT: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_GROUP_CHAT; break;
        case RIL_UNSOL_OEM_AIMS_RCS_OFFLINE_MODE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_OFFLINE_MODE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_FILE_TRANSFER: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_FILE_TRANSFER; break;
        case RIL_UNSOL_OEM_AIMS_RCS_COMMON_MESSAGE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_COMMON_MESSAGE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_CONTENT_SHARE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_CONTENT_SHARE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_PRESENCE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_PRESENCE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_XCAP_MANAGE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_XCAP_MANAGE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_CONFIG_MANAGE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_CONFIG_MANAGE; break;
        case RIL_UNSOL_OEM_AIMS_RCS_TLS_MANAGE: rilcUnsolRspId = RILC_UNSOL_AIMS_RCS_TLS_MANAGE; break;
        case RIL_UNSOL_OEM_AIMS_MEDIA_STATUS: rilcUnsolRspId = RILC_UNSOL_AIMS_MEDIA_STATUS; break;
        case RIL_UNSOL_OEM_AIMS_AC_BARRING_INFO: rilcUnsolRspId = RILC_UNSOL_AIMS_AC_BARRING_INFO; break;
        case RIL_UNSOL_OEM_AIMS_SIP_MSG_INFO: rilcUnsolRspId = RILC_UNSOL_AIMS_SIP_MSG_INFO; break;
        case RIL_UNSOL_OEM_AIMS_VOICE_RTP_QUALITY: rilcUnsolRspId = RILC_UNSOL_AIMS_VOICE_RTP_QUALITY; break;
        case RIL_UNSOL_OEM_AIMS_RTP_RX_STATISTICS: rilcUnsolRspId = RILC_UNSOL_AIMS_RTP_RX_STATISTICS; break;

        case RIL_UNSOL_OEM_WFC_RTP_RTCP_TIMEOUT: rilcUnsolRspId = RILC_UNSOL_WFC_RTP_RTCP_TIMEOUT; break;
        case RIL_UNSOL_OEM_WFC_FIRST_RTP: rilcUnsolRspId = RILC_UNSOL_WFC_FIRST_RTP; break;
        case RIL_UNSOL_OEM_WFC_RTCP_RX_SR: rilcUnsolRspId = RILC_UNSOL_WFC_RTCP_RX_SR; break;
        case RIL_UNSOL_OEM_WFC_RCV_DTMF_NOTI: rilcUnsolRspId = RILC_UNSOL_WFC_RCV_DTMF_NOTI; break;
        case RIL_UNSOL_OEM_WFC_SIGNAL_STRENGTH: rilcUnsolRspId = RILC_UNSOL_WFC_SIGNAL_STRENGTH; break;

        /* eMBMS */
        case RIL_UNSOL_OEM_EMBMS_COVERAGE: rilcUnsolRspId = RILC_UNSOL_EMBMS_COVERAGE; break;
        case RIL_UNSOL_OEM_EMBMS_SESSION_LIST: rilcUnsolRspId = RILC_UNSOL_EMBMS_SESSION_LIST; break;
        case RIL_UNSOL_OEM_EMBMS_SIGNAL_STRENGTH: rilcUnsolRspId = RILC_UNSOL_EMBMS_SIGNAL_STRENGTH; break;
        case RIL_UNSOL_OEM_EMBMS_NETWORK_TIME: rilcUnsolRspId = RILC_UNSOL_EMBMS_NETWORK_TIME; break;
        case RIL_UNSOL_OEM_EMBMS_SAI_LIST: rilcUnsolRspId = RILC_UNSOL_EMBMS_SAI_LIST; break;
        case RIL_UNSOL_OEM_EMBMS_GLOBAL_CELL_ID: rilcUnsolRspId = RILC_UNSOL_EMBMS_GLOBAL_CELL_ID; break;
        case RIL_UNSOL_OEM_EMBMS_RADIO_STATE_CHANGED: rilcUnsolRspId = RILC_UNSOL_EMBMS_RADIO_STATE_CHANGED; break;
        case RIL_UNSOL_OEM_EMBMS_MODEM_STATUS: rilcUnsolRspId = RILC_UNSOL_EMBMS_MODEM_STATUS; break;
        case RIL_UNSOL_OEM_EMBMS_SESSION_CONTROL: rilcUnsolRspId = RILC_UNSOL_EMBMS_SESSION_CONTROL; break;

        // OEM2
        case RIL_UNSOL_OEM_PSENSOR_CONTROL_STATE: rilcUnsolRspId = RILC_UNSOL_PSENSOR_CONTROL_STATE; break;
        case RIL_UNSOL_OEM_VSIM_OPERATION: rilcUnsolRspId = RILC_UNSOL_VSIM_OPERATION; break;
        case RIL_UNSOL_OEM_SAR_RF_CONNECTION: rilcUnsolRspId = RILC_UNSOL_SAR_RF_CONNECTION; break;
        case RIL_UNSOL_OEM_CA_BANDWIDTH_FILTER: rilcUnsolRspId = RILC_UNSOL_CA_BANDWIDTH_FILTER; break;

        case RIL_UNSOL_OEM_SELFLOG_STATUS: rilcUnsolRspId = RILC_UNSOL_SELFLOG_STATUS; break;

        // OEM5
        case RIL_UNSOL_OEM_MODEM_INFO: rilcUnsolRspId = RILC_UNSOL_MODEM_INFO; break;
        case RIL_UNSOL_OEM_RTP_PKTLOSS_THRESHOLD: rilcUnsolRspId = RILC_UNSOL_RTP_PKTLOSS_THRESHOLD; break;
        case RIL_UNSOL_OEM_FREQUENCY_INFO: rilcUnsolRspId = RILC_UNSOL_FREQUENCY_INFO; break;
        case RIL_UNSOL_OEM_AMBR: rilcUnsolRspId = RILC_UNSOL_AMBR; break;
        case RIL_UNSOL_B2_B1_CONFIG_INFO: rilcUnsolRspId = RILC_UNSOL_B2_B1_CONFIG_INFO; break;

        default: RLOGW("unsupported unsolicited response %d", unsolResponse); break;
    }
    return rilcUnsolRspId;
}

/* This is not used, ExteranlUnsolResponse is broadcasted to all clients*/
/*
static int getClientIdForExternalUnsolResponse(int rilcUnsolRspId,  int slotId) {
   int clientId = (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM;

    switch (rilcUnsolRspId) {
        case RILC_UNSOL_IMS_CONFIGURATION:
        case RILC_UNSOL_IMS_DEDICATED_PDN_INFO:
        case RILC_UNSOL_IMS_EMERGENCY_ACT_INFO:
        case RILC_UNSOL_IMS_SRVCC_HO:
        case RILC_UNSOL_IMS_EMERGENCY_CALL_LIST:
        case RILC_UNSOL_IMS_SUPPORT_SERVICE:
        case RILC_UNSOL_IMS_OPEN_CARRIER_INFO:
             clientId = RADIO_EXTERNAL_CLIENT_IMS;
             break;

        case RILC_UNSOL_GPS_MEASURE_POS_REQ:
        case RILC_UNSOL_GPS_ASSIST_DATA:
        case RILC_UNSOL_GPS_RELEASE_GPS:
        case RILC_UNSOL_GPS_MT_LOCATION_REQUEST:
        case RILC_UNSOL_GPS_RESET_GPS_ASSIST_DATA:
        case RILC_UNSOL_GPS_LPP_REQUEST_CAPABILITIES:
        case RILC_UNSOL_GPS_LPP_PROVIDE_ASSIST_DATA:
        case RILC_UNSOL_GPS_LPP_REQUEST_LOCATION_INFO:
        case RILC_UNSOL_GPS_LPP_GPS_ERROR_IND:
        case RILC_UNSOL_GPS_SUPL_LPP_DATA_INFO:
        case RILC_UNSOL_GPS_SUPL_NI_MESSAGE:
        case RILC_UNSOL_GPS_3GPP_SEND_GANSS_ASSIT_DATA:
        case RILC_UNSOL_GPS_GANSS_MEAS_POS_MSG:
        case RILC_UNSOL_GPS_CDMA_GPS_POWER_ON:
        case RILC_UNSOL_GPS_CDMA_SEND_ACQUSITION_ASSIT_DATA:
        case RILC_UNSOL_GPS_CDMA_SESSION_CANCELLATION:
        case RILC_UNSOL_GPS_GANSS_AP_POS_CAP_REQ:
            clientId = RADIO_EXTERNAL_CLIENT_GPS;
            break;

        case RILC_UNSOL_DISPLAY_ENG_MODE:
        case RILC_UNSOL_JNIIF_START_ACTIVITY:
        case RILC_UNSOL_JNIIF_START_SERVICE:
        case RILC_UNSOL_JNIIF_STOP_SERVICE:
        case RILC_UNSOL_JNIIF_SEND_BROADCAST:
        case RILC_UNSOL_PIN_CONTROL:
        case RILC_UNSOL_AM:
            clientId = RADIO_EXTERNAL_CLIENT_JNIF;
            break;

        case RILC_UNSOL_AIMS_CALL_RING:
        case RILC_UNSOL_AIMS_CALL_STATUS:
        case RILC_UNSOL_AIMS_REGISTRATION:
        case RILC_UNSOL_AIMS_CALL_MODIFY:
        case RILC_UNSOL_AIMS_FRAME_TIME:
        case RILC_UNSOL_AIMS_SUPP_SVC_NOTIFICATION:
        case RILC_UNSOL_AIMS_NEW_SMS:
        case RILC_UNSOL_AIMS_NEW_SMS_STATUS_REPORT:
        case RILC_UNSOL_AIMS_ON_USSD:
        case RILC_UNSOL_AIMS_CONFERENCE_CALL_EVENT:
        case RILC_UNSOL_AIMS_HO_PAYLOAD:
        case RILC_UNSOL_AIMS_VOWIFI_HO_CALL_INFO:
        case RILC_UNSOL_AIMS_NEW_CDMA_SMS:
        case RILC_UNSOL_AUDIO_RINGBACK:
        case RILC_UNSOL_AIMS_CALL_MANAGE:
        case RILC_UNSOL_AIMS_CONF_CALL_ADD_REMOVE_USER:
        case RILC_UNSOL_AIMS_ENHANCED_CONF_CALL:
        case RILC_UNSOL_AIMS_CALL_MODIFY_RSP:
        case RILC_UNSOL_AIMS_DTMF_EVENT:
            clientId = RADIO_EXTERNAL_CLIENT_IMS;
            break;

        case RILC_UNSOL_WFC_RTP_RTCP_TIMEOUT:
        case RILC_UNSOL_WFC_FIRST_RTP:
        case RILC_UNSOL_WFC_RTCP_RX_SR:
        case RILC_UNSOL_WFC_RCV_DTMF_NOTI:
            clientId = RADIO_EXTERNAL_CLIENT_WLAN;
            break;

        default:
            RilLogW("unsupported RILC unsolicited response %d", rilcUnsolRspId);
            break;
    }
    return clientId;
}
*/

static int external_checkAndDequeueRequest(struct RadioExternalRequestInfo *pRI) {
    int ret = 0;
    // Hook for current context
    pthread_mutex_t* pendingRequestsMutexHook = &s_external_pendingRequestsMutex;
    RadioExternalRequestInfo ** pendingRequestsHook = &s_external_pendingRequests;

    if (pRI == NULL) {
        return 0;
    }

    pthread_mutex_lock(pendingRequestsMutexHook);

    for(RadioExternalRequestInfo **ppCur = pendingRequestsHook
        ; *ppCur != NULL
        ; ppCur = &((*ppCur)->p_next)
    ) {
        if (pRI == *ppCur) {
            ret = 1;
            *ppCur = (*ppCur)->p_next;
            break;
        }
    }

    pthread_mutex_unlock(pendingRequestsMutexHook);

    return ret;
}

static RadioExternalRequestInfo *external_addRequestToList(int serial, int clientId, int rilcReqId, int slotId) {
    RadioExternalRequestInfo *pRI;
    int ret;
    int rilOemReqId;
    pthread_mutex_t* pendingRequestsMutexHook = &s_external_pendingRequestsMutex;
    RadioExternalRequestInfo**    pendingRequestsHook = &s_external_pendingRequests;

    if (clientId < 0 || clientId >= (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM) {
        RLOGE("addRequestToList: Invalid Radio Extern Client ID %d, rilcReqId %d",
                clientId, rilcReqId);
        return NULL;
    }

    pRI = (RadioExternalRequestInfo *)calloc(1, sizeof(RadioExternalRequestInfo));
    if (pRI == NULL) {
        RLOGE("addRequestToList:Memory allocation failed for request %s", rilcRequestToString(rilcReqId));
        return NULL;
    }

    rilOemReqId = convertRilcReqId2RilOemReqId(rilcReqId);

    pRI->serial = serial;
    pRI->clientId = clientId;
    pRI->rilcReqId = rilcReqId;
    pRI->slotId = slotId;
    pRI->rilOemReqId = rilOemReqId;
    pRI->responseFunction = getResponseFunction(rilcReqId);

    ret = pthread_mutex_lock(pendingRequestsMutexHook);
    assert (ret == 0);

    pRI->p_next = *pendingRequestsHook;
    *pendingRequestsHook = pRI;

    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
    assert (ret == 0);

    return pRI;
}

static void external_sendErrorResponse(RadioExternalRequestInfo *pRI, RIL_Errno err) {
        pRI->responseFunction(pRI->clientId, pRI->rilcReqId, pRI->slotId, pRI->serial, err, NULL, 0);
}

static bool external_dispatchRaw(int serial, int clientId, int rilcReqId, int slotId, int dataLen, const hidl_vec<uint8_t>& rawBytes) {
    RadioExternalRequestInfo *pRI = external_addRequestToList(serial, clientId, rilcReqId, slotId);
    if (pRI == NULL) {
        return false;
    }

    if (pRI->rilOemReqId == RIL_REQUEST_OEM_INVALID) {
        external_sendErrorResponse(pRI, RIL_E_INVALID_ARGUMENTS);
        return false;
    }

    const uint8_t *uData = rawBytes.data();

    EXTERNAL_CALL_ONREQUEST(pRI->rilOemReqId, pRI, (void *)uData, rawBytes.size(), pRI->slotId);

    return true;
}

extern "C" void
RIL_External_onRequestComplete(RIL_External_Token t, RIL_Errno e, void *response, size_t responselen) {
    RadioExternalRequestInfo *pRI;
    int ret;
    int socket_id;

    pRI = (RadioExternalRequestInfo *)t;

    if (pRI == NULL || !external_checkAndDequeueRequest(pRI)) {
        RLOGE ("RIL_External_onRequestComplete: invalid RIL_External_Token");
        return;
    }

    socket_id = pRI->slotId;

    if (pRI->responseFunction != NULL) {

        pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
        int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
        assert(rwlockRet == 0);

        ret = pRI->responseFunction(pRI->clientId, pRI->rilcReqId, pRI->slotId, pRI->serial, e, response, responselen);

        rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
        assert(rwlockRet == 0);
    }
    free(pRI);
}


extern "C" void
RIL_External_onUnsolicitedResponse(int unsolResponse, const void *data,
                                size_t datalen, int slotId)
{
    int clientId = (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM;
    int ret;
    int rilcUnsolRspId;

    if (s_external_registerCalled == 0) {
        // Ignore RIL_External_onUnsolicitedResponse before RIL_External_register
        RLOGW("RIL_External_onUnsolicitedResponse called before RIL_External_register");
        return;
    }

    // if channel == RIL_SOCKET_NUM : unknown socket id -> should be decided in RILApplication
    if (slotId > RIL_SOCKET_NUM) {
        RLOGW("RIL_External_onUnsolicitedResponse: invalid slot ID");
        return;
    }

    rilcUnsolRspId = convertRilOemUnsolRspId2RilcRespId(unsolResponse);
    if (rilcUnsolRspId == RILC_UNSOL_NOT_SUPPORTED) {
        RLOGW("RIL_External_onUnsolicitedResponse: unsupported RIL OEM UNSOL(%d)", unsolResponse);
        return;
    }

    /* This is not used, ExteranlUnsolResponse is broadcasted to all clients*/
    //clientId = getClientIdForExternalUnsolResponse(rilcUnsolRspId, slotId);

    // Grab a wake lock if needed for this reponse,
    //grabPartialWakeLock();
    //shouldScheduleTimeout = true;

    pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
    int rwlockRet = pthread_rwlock_rdlock(radioServiceRwlockPtr);
    assert(rwlockRet == 0);

    if (datalen > MAX_RADIO_DATA_SIZE) {
        ret = radioExternal::rilExternalRawIndicationSeg(clientId, rilcUnsolRspId, slotId, data, datalen);
    } else {
        ret = radioExternal::rilExternalRawIndication(clientId, rilcUnsolRspId, slotId, data, datalen);
    }

    rwlockRet = pthread_rwlock_unlock(radioServiceRwlockPtr);
    assert(rwlockRet == 0);

    // Normal exit
    return;
}

struct RadioExternalImpl : public IOemSlsiRadioExternal {
    int mAvailableClientFlag;

    sp<IOemSlsiRadioExternalRes> mOemSlsiRadioExternalRes[(int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM];
    sp<IOemSlsiRadioExternalInd> mOemSlsiRadioExternalInd[(int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM];

    void checkReturnStatus(int32_t clientId, int32_t slotId, Return<void>& ret);
    int determineClientId(void);

    Return<int32_t> setResponseFunctions(
            const ::android::sp<IOemSlsiRadioExternalRes>& radioResponseParam,
            const ::android::sp<IOemSlsiRadioExternalInd>& radioIndicationParam);

    Return<void> clearResponseFunctions(int32_t clientId);

    Return<void> sendRequestRaw(int32_t serial,
            int32_t clientId,
            int32_t rilcReqid,
            int32_t slotId,
            int32_t dataLen,
            const ::android::hardware::hidl_vec<uint8_t>& data);

    Return<void> sendRequestRawSegment(int32_t serial,
            int32_t clientId,
            int32_t rilcReqid,
            int32_t slotId,
            int32_t dataLen,
            const ::android::hardware::hidl_vec<uint8_t>& data,
            int32_t segIndex,
            int32_t totalLen);
};

void RadioExternalImpl::checkReturnStatus(int32_t clientId, int32_t slotId, Return<void>& ret) {
    if (ret.isOk() == false) {
        RLOGE("checkReturnStatus: unable to call response/indication callback for clientId [%d]",
                clientId);
        // Remote process hosting the callbacks must be dead. Reset the callback objects;
        // there's no other recovery to be done here. When the client process is back up, it will
        // call setResponseFunctions()

        // Caller should already hold rdlock, release that first
        // note the current counter to avoid overwriting updates made by another thread before
        // write lock is acquired.
        int counter = mCounterRadioExternalClient[clientId];
        pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
        int ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
        assert(ret == 0);

        // acquire wrlock
        ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
        assert(ret == 0);

        // make sure the counter value has not changed
        if (counter == mCounterRadioExternalClient[clientId]) {
            mOemSlsiRadioExternalRes[clientId] = NULL;
            mOemSlsiRadioExternalInd[clientId] = NULL;
            mAvailableClientFlag = mAvailableClientFlag & (~(0x1 << clientId));
            mCounterRadioExternalClient[clientId]++;
            for(int i = 0; i < MAX_NUM_REQ_RAW_SEGMENT; ++i) {
                struct RequestRawSegmentData *accData = &reqRawSegData[i];
                if ( accData->clientId == clientId) accData->reset();
            }
        } else {
            RLOGE("checkReturnStatus: not resetting responseFunctions as they likely "
                    "got updated on another thread [%d] != [%d]",
                    counter, mCounterRadioExternalClient[clientId]);
        }

        // release wrlock
        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
        assert(ret == 0);

        // Reacquire rdlock
        ret = pthread_rwlock_rdlock(radioServiceRwlockPtr);
        assert(ret == 0);
    }
}

int RadioExternalImpl::determineClientId(void) {
    int maxClientNum = (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM;
    int clientId, i, ret;

    pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
    ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
    assert(ret == 0);

    for (i = 0; i < maxClientNum;i++) {
        if ((mAvailableClientFlag & (0x1 << i)) == 0) break;
    }
    clientId = i;
    mAvailableClientFlag = mAvailableClientFlag |(0x1 << i);
    ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
    assert(ret == 0);

    return clientId;
}

Return<int32_t> RadioExternalImpl::setResponseFunctions(
        const ::android::sp<IOemSlsiRadioExternalRes>& radioResponseParam,
        const ::android::sp<IOemSlsiRadioExternalInd>& radioIndicationParam) {

    int clientId = determineClientId();
    RLOGD("setResponseFunctions client ID %d", clientId);

    if (clientId >= 0 && clientId < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM) {
        pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
        int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
        assert(ret == 0);

        mOemSlsiRadioExternalRes[clientId] = radioResponseParam;
        mOemSlsiRadioExternalInd[clientId]  = radioIndicationParam;
        mCounterRadioExternalClient[clientId]++;

        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
        assert(ret == 0);
    } else {
        RLOGE("setResponseFunctions: Invalid Radio Extern Client ID %d", clientId);
    }

    return Return<int32_t>(clientId);
}


Return<void> RadioExternalImpl::clearResponseFunctions(int32_t clientId) {

    RLOGD("clearResponseFunctions requested client ID %d", clientId);

    if (clientId >= 0 && clientId < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM) {
        pthread_rwlock_t *radioServiceRwlockPtr = radioExternal::getRadioExternalServiceRwlock();
        int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
        assert(ret == 0);

        mOemSlsiRadioExternalRes[clientId] = NULL;
        mOemSlsiRadioExternalInd[clientId]  = NULL;
        mCounterRadioExternalClient[clientId]++;
        mAvailableClientFlag = mAvailableClientFlag & (~(0x1 << clientId));

        for(int i = 0; i < MAX_NUM_REQ_RAW_SEGMENT; ++i) {
            struct RequestRawSegmentData *accData = &reqRawSegData[i];
            if ( accData->clientId == clientId) accData->reset();
        }

        ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
        assert(ret == 0);
    } else {
        RLOGE("clearResponseFunctions: Invalid Radio Extern Client ID %d", clientId);
    }
    return Void();
}

Return<void> RadioExternalImpl::sendRequestRaw(int32_t serial,
            int32_t clientId,
            int32_t rilcReqId,
            int32_t slotId,
            int32_t dataLen,
            const ::android::hardware::hidl_vec<uint8_t>& data){
    if (RIL_EXTERN_VDBG) {
        RLOGD("sendRequestRaw: %s serial %d, clientId %d, slotId %d",
                rilcRequestToString(rilcReqId), serial, clientId,  slotId);
    }

    dataLen = data.size();    // dataLen comes with 0 value. so update dateLen by using hidl_vec in order to make sure.
    external_dispatchRaw(serial, clientId, rilcReqId, slotId, dataLen, data);

    return Void();
}

Return<void>  RadioExternalImpl::sendRequestRawSegment(int32_t serial,
            int32_t clientId,
            int32_t rilcReqId,
            int32_t slotId,
            int32_t dataLen,
            const ::android::hardware::hidl_vec<uint8_t>& data,
            int32_t segIndex,
            int32_t totalLen){

    int queIndex = 0;
    struct RequestRawSegmentData *accData = NULL;

    if (segIndex == 0) {
        for (queIndex = 0; queIndex < MAX_NUM_REQ_RAW_SEGMENT; ++queIndex){
            accData = &reqRawSegData[queIndex];
            if (accData->pData == NULL) {
                accData->pData = new uint8_t[totalLen];
                accData->serial = serial;
                accData->clientId = clientId;
                accData->rilcReqId = rilcReqId;
                accData->slotId = slotId;
                accData->totalLen = totalLen;
                accData->accLen = 0;
                break;
            }
        }

        if (queIndex >= MAX_NUM_REQ_RAW_SEGMENT) {
            RLOGE("reqRawSegData is full: %s serial %d, clientId %d, slotId %d",
                rilcRequestToString(rilcReqId), serial, clientId,  slotId);

            RadioExternalRequestInfo *pRI = external_addRequestToList(serial, clientId, rilcReqId, slotId);
            if (pRI != NULL) {
                external_sendErrorResponse(pRI, RIL_E_INTERNAL_ERR);
            }

            // If necessary, reset all of reqRawSegData
            for(int i = 0; i < MAX_NUM_REQ_RAW_SEGMENT; ++i) {
                accData = &reqRawSegData[i];
                accData->reset();
            }

            return Void();
        }
    } else {
        for (queIndex = 0; queIndex < MAX_NUM_REQ_RAW_SEGMENT; ++queIndex){
            accData = &reqRawSegData[queIndex];
            if (accData->pData != NULL
                && accData->serial == serial && accData->clientId == clientId
                && accData->rilcReqId == rilcReqId && accData->slotId == slotId) break ;
        }

        if (queIndex >= MAX_NUM_REQ_RAW_SEGMENT) {
            RLOGE("reqRawSegData is not found: %s serial %d, clientId %d, slotId %d, segIndex %d",
                rilcRequestToString(rilcReqId), serial, clientId,  slotId, segIndex);
            return Void();
        }
    }

    dataLen = data.size();  // dataLen comes with 0 value. so update dateLen by using hidl_vec in order to make sure.
    if (RIL_EXTERN_VDBG) {
        RLOGD("sendRequestRawSegment: %s serial %d, clientId %d, slotId %d, segIndex %d, queIndex %d, dataLen %d totalLen = %d",
                rilcRequestToString(rilcReqId), serial, clientId,  slotId, segIndex, queIndex, dataLen, totalLen);
    }

    if(accData != NULL && accData->pData != NULL){
        uint8_t *dst = accData->pData + segIndex * MAX_RADIO_DATA_SIZE;
        const uint8_t *src = data.data();
        memcpy(dst, src, dataLen);
        accData->accLen += dataLen;

        if (accData->accLen >= accData->totalLen) {
            hidl_vec<uint8_t> sendData;
            sendData.setToExternal(accData->pData, accData->accLen);
            external_dispatchRaw(serial, clientId, rilcReqId, slotId, accData->accLen, sendData);

            if (RIL_EXTERN_VDBG) {
                RLOGD("sendRequestRawSegment: dispatched %s serial %d, clientId %d, slotId %d, accLen %d, totalLen %d",
                    rilcRequestToString(rilcReqId), serial, clientId,  slotId, accData->accLen, accData->totalLen);
            }
            accData->reset();
        }
    }

    return Void();
}

void populateRadioExternalResponseInfo(RadioExternalResponseInfo& responseInfo,
                        int rilcMsgId,
                        int slotId,
                        int serial,
                        RIL_Errno e,
                        size_t responseLen) {
    responseInfo.slotId = slotId;
    responseInfo.serial = serial;
    responseInfo.rilcMsgId = rilcMsgId;
    responseInfo.length = responseLen;
    switch (e) {
        case RIL_E_SUCCESS:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_NONE;
            break;
        case RIL_E_INVALID_ARGUMENTS:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_INVALID_ARGUMENTS;
            break;
        case RIL_E_MISSING_RESOURCE:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_MISSING_RESOURCE;
            break;
        case RIL_E_NO_SUCH_ELEMENT:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_NO_SUCH_ELEMENT;
            break;
        case RIL_E_INTERNAL_ERR:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_INTERNAL_ERR;
            break;
        case RIL_E_NO_MEMORY:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_NO_MEMORY;
            break;
        case RIL_E_NO_RESOURCES:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_NO_RESOURCES;
            break;
        case RIL_E_CANCELLED:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_CANCELLED;
            break;
        case RIL_E_SIM_ERR:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_SIM_ERROR;
            break;
        case RIL_E_INVALID_SIM_STATE:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_INVALID_SIM_STATUS;
            break;
        case RIL_E_FDN_CHECK_FAILURE:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_FDN_CHECK_FAILURE;
            break;
        case RIL_E_REQUEST_NOT_SUPPORTED:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_REQUEST_NOT_SUPPORTED;
            break;
        default:
            responseInfo.error = RadioExternalError::RADIO_EXTERNAL_GENERIC_FAILURE;
            break;
    }
}

void radioExternal::registerService(const RIL_RadioExternalFunctions *callbacks) {
    int iLoop;

    using namespace android::hardware;
    const char *serviceNames[] = {
            RIL_EXTERNAL_SERVICE_NAME
            };

    if (s_external_registerCalled > 0) {
        RLOGE("RIL_External_register has been called more than once. Subsequent call ignored");
        return;
    }

    configureRpcThreadpool(1, true /* callerWillJoin */);

    pthread_rwlock_t *radioServiceRwlockPtr = getRadioExternalServiceRwlock();
    int ret = pthread_rwlock_wrlock(radioServiceRwlockPtr);
    assert(ret == 0);

    radioExeternalService[0] = new RadioExternalImpl;
    radioExeternalService[0]->mAvailableClientFlag = 0;
    for (iLoop = 0; iLoop < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM; iLoop++) {
        radioExeternalService[0]->mOemSlsiRadioExternalRes[iLoop] = NULL;
        radioExeternalService[0]->mOemSlsiRadioExternalInd[iLoop] = NULL;
    }

    for(iLoop = 0; iLoop < MAX_NUM_REQ_RAW_SEGMENT; ++iLoop) {
        struct RequestRawSegmentData *accData = &reqRawSegData[iLoop];
        accData->reset();
    }


    RLOGD("registerService: starting IRadioExternal %s", serviceNames[0]);
    android::status_t status = radioExeternalService[0]->registerAsService(serviceNames[0]);

    ret = pthread_rwlock_unlock(radioServiceRwlockPtr);
    assert(ret == 0);

    memcpy(&s_external_vendorCallbacks, callbacks, sizeof(RIL_RadioExternalFunctions));

    s_external_vendorFunctions = &s_external_vendorCallbacks;

    s_external_registerCalled = 1;
    if (status != 0) {
        if (RIL_EXTERN_VDBG) RLOGD("registerService: %s registered", serviceNames[0]);
    }
    else {
        RLOGW("registerService: failed. service_name=%s", serviceNames[0]);
    }
}

pthread_rwlock_t * radioExternal::getRadioExternalServiceRwlock() {
    pthread_rwlock_t *radioServiceRwlockPtr = &radioExternalServiceRwlock;

    return radioServiceRwlockPtr;
}

int radioExternal::sendRequestRawResponse(int clientId,
                        int rilcMsgId,
                        int slotId,
                        int serial,
                        RIL_Errno e,
                        void *response,
                        size_t responseLen) {

    if (responseLen > MAX_RADIO_DATA_SIZE) {
        sendRequestRawResponseSeg(clientId, rilcMsgId, slotId, serial, e, response, responseLen);
        return 0;
    }

    if (radioExeternalService[0] == NULL) {
        RLOGE("sendRequestRawResponse: RIL External service is not registered");
        return 0;
    }

    RLOGD("sendRequestRawResponse: serial %d, rilcMsgId %d slotId %d RIL_Errno %d", serial, rilcMsgId, slotId, e);

    if (clientId >= 0
            && clientId < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM
            && radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId] != NULL) {
        RadioExternalResponseInfo responseInfo = {};
        populateRadioExternalResponseInfo(responseInfo, rilcMsgId, slotId, serial, e, responseLen);

        hidl_vec<uint8_t> sendData;
        if (response == NULL) {
            if (RIL_EXTERN_VDBG) RLOGD("sendRequestRawResponse: no data in response");
        } else {
            sendData.setToExternal((uint8_t *) response, responseLen);
        }
        Return<void> retStatus = radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId]->
            sendRequestRawResponse(responseInfo, sendData);
        radioExeternalService[0]->checkReturnStatus(clientId, slotId, retStatus);
    } else {
        RLOGE("sendRequestRawResponse: Invalid Radio Extern Client ID(=%d) or response object is not registered", clientId);
    }

    return 0;
}

int radioExternal::sendRequestRawResponseSeg(int clientId,
                        int rilcMsgId,
                        int slotId,
                        int serial,
                        RIL_Errno e,
                        void *response,
                        size_t responseLen) {
    if (radioExeternalService[0] == NULL) {
        RLOGE("sendRequestRawResponse(Seg): RIL External service is not registered");
        return 0;
    }

    RLOGD("sendRequestRawResponse(Seg): serial %d, rilcMsgId %d slotId %d", serial, rilcMsgId, slotId);

    if (response == NULL) {
        RLOGD("sendRequestRawResponse(Seg): no data in response");
    }

    if (clientId >= 0
            && clientId < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM
            && radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId] != NULL) {
        int segIndex;
        int num = (responseLen + MAX_RADIO_DATA_SIZE - 1) / MAX_RADIO_DATA_SIZE;
        const uint8_t *rspData = (const uint8_t *)response;

        for (segIndex = 0; segIndex < num; ++segIndex) {
            int segLength = (segIndex == num-1) ? responseLen&MAX_RADIO_DATA_MOD : MAX_RADIO_DATA_SIZE;

            RadioExternalResponseInfo responseInfo = {};
            populateRadioExternalResponseInfo(responseInfo, rilcMsgId, slotId, serial, e, segLength);

            hidl_vec<uint8_t> sendData;
            if (segLength > 0) sendData.setToExternal((uint8_t *)rspData, segLength);
            Return<void> retStatus = radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId]->
                sendRequestRawResponseSeg(responseInfo, sendData, segIndex, responseLen);
            radioExeternalService[0]->checkReturnStatus(clientId, slotId, retStatus);

            rspData += segLength;
        }
    } else {
        RLOGE("sendRequestRawResponse: Invalid Radio Extern Client ID(=%d) or response object is not registered", clientId);
    }

    return 0;
}

int radioExternal::rilExternalRawIndication(int clientId,
                        int rilcMsgId,
                        int slotId,
                        const void *indication,
                        size_t indicationLen) {
    int iLoop;

    if (radioExeternalService[0] == NULL) {
        RLOGE("rilExternalRawIndication: RIL External service is not registered");
        return 0;
    }

    //ExteranlUnsolResponse is broadcasted to all clients*/
    for (iLoop = 0; iLoop < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM; iLoop++) {
        if (radioExeternalService[0]->mOemSlsiRadioExternalInd[iLoop] != NULL) {
            if (RIL_EXTERN_VDBG) RLOGD("rilExternalRawIndication: rilcMsgId %d, slotId %d, clientIndex %d", rilcMsgId, slotId, iLoop);
            hidl_vec<uint8_t> data;
            data.setToExternal((uint8_t *) indication, indicationLen);

            Return<void> retStatus = radioExeternalService[0]->mOemSlsiRadioExternalInd[iLoop]->
                rilExternalRawIndication(rilcMsgId, slotId, data, indicationLen);
            radioExeternalService[0]->checkReturnStatus(iLoop, slotId, retStatus);
        } else {
            //if (RIL_EXTERN_VDBG) RLOGD("rilExternalRawIndication: client(%d) not registered", iLoop);
        }
    }
    return 0;
}

int radioExternal::rilExternalRawIndicationSeg(int clientId,
                        int rilcMsgId,
                        int slotId,
                        const void *indication,
                        size_t indicationLen) {
    int iLoop;
    int segIndex;
    int num = (indicationLen + MAX_RADIO_DATA_SIZE - 1) / MAX_RADIO_DATA_SIZE;
    const uint8_t *data = (const uint8_t *)indication;

    if (radioExeternalService[0] == NULL) {
        RLOGE("rilExternalRawIndication(Seg): RIL External service is not registered");
        return 0;
    }

    if (RIL_EXTERN_VDBG) {
        RLOGD("rilExternalRawIndication(Seg): rilcMsgId %d, slotId %d, total_len = %zu",
            rilcMsgId, slotId, indicationLen);
    }

    for (segIndex = 0; segIndex < num; ++segIndex) {
        hidl_vec<uint8_t> sendData;
        int segLength = (segIndex == num-1) ? indicationLen&MAX_RADIO_DATA_MOD : MAX_RADIO_DATA_SIZE;

        sendData.setToExternal((uint8_t *)data, segLength);

        //ExteranlUnsolResponse is broadcasted to all clients*/
        for (iLoop = 0; iLoop < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM; iLoop++) {
            if (radioExeternalService[0]->mOemSlsiRadioExternalInd[iLoop] != NULL) {
                if (RIL_EXTERN_VDBG) {
                    RLOGD("rilExternalRawIndication(Seg): rilcMsgId %d, slotId %d, clientIndex %d, segIndex %d, dataLen = %d, total_len = %zu",
                        rilcMsgId, slotId, iLoop, segIndex, segLength, indicationLen);
                }

                Return<void> retStatus = radioExeternalService[0]->mOemSlsiRadioExternalInd[iLoop]->
                    rilExternalRawIndicationSeg(rilcMsgId, slotId, sendData, segLength, segIndex, indicationLen);
                radioExeternalService[0]->checkReturnStatus(iLoop, slotId, retStatus);
            } else {
                //if (RIL_EXTERN_VDBG) RLOGD("rilExternalRawIndicationSeg: client(%d) not registered", iLoop);
            }
        }

        data += segLength;
    }

    return 0;
}

int radioExternal::getAvailableNtworksResponse(int clientId, int rilcMsgId, int slotId, int serial,
        RIL_Errno e, void *response, size_t responseLen)
{
#if VDBG
    RLOGD("%s(): %d", __FUNCTION__, serial);
#endif
    if (responseLen > MAX_RADIO_DATA_SIZE) {
        return 0;
    }

    if (radioExeternalService[0] == NULL) {
        RLOGE("%s: RIL External service is not registered", __FUNCTION__);
        return 0;
    }

    RLOGD("%s: serial %d, rilcMsgId %d slotId %d", __FUNCTION__, serial, rilcMsgId, slotId);

    if (clientId >= 0
            && clientId < (int)RadioExternalClientId::RADIO_EXTERNAL_CLIENT_NUM
            && radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId] != NULL) {
        RadioExternalResponseInfo responseInfo = {};
        populateRadioExternalResponseInfo(responseInfo, rilcMsgId, slotId, serial, e, responseLen);

        OEM_OperatorInfo *operatorInfos = NULL;
        hidl_vec<uint8_t> sendData;
        sendData.resize(0);
        if ((response == NULL && responseLen != 0) || responseLen % (sizeof(char *) * 4) != 0) {
            if (RIL_EXTERN_VDBG) RLOGD("sendRequestRawResponse: no data in response");
            if (e != RIL_E_SUCCESS) responseInfo.error = RadioExternalError::RADIO_EXTERNAL_GENERIC_FAILURE;
            sendData.resize(0);
        } else {
            int len = (int)(responseLen / sizeof(char *));
            int num = len / 4;
            RLOGD("responseLen=%zu num=%d", responseLen, num);
#if VDBG
            for (int i = 0; i < len; i++)
                RLOGD("[%d] %s", i, ((char **)response)[i]);
#endif
            operatorInfos = new OEM_OperatorInfo[num];
            if (operatorInfos != NULL) {
                for (int i = 0; i < num; i++) {
                    // alpha long
                    if (((char **)response)[i * 4] != NULL) {
                        memset(operatorInfos[i].alphaLong, 0, sizeof(operatorInfos[i].alphaLong));
                        strncpy(operatorInfos[i].alphaLong, ((char **)response)[i * 4], MAX_ALPHA_LONG_NAME - 1);
                    }
                    // alpha short
                    if (((char **)response)[i * 4 + 1] != NULL) {
                        memset(operatorInfos[i].alphaShort, 0, sizeof(operatorInfos[i].alphaShort));
                        strncpy(operatorInfos[i].alphaShort, ((char **)response)[i * 4 + 1], MAX_ALPHA_SHORT_NAME - 1);
                    }
                    // alpha numeric
                    if (((char **)response)[i * 4 + 2] != NULL) {
                        memset(operatorInfos[i].numeric, 0, sizeof(operatorInfos[i].numeric));
                        strncpy(operatorInfos[i].numeric, ((char **)response)[i * 4 + 2], MAX_PLMN_LEN);
                    }
                    // status
                    if (((char **)response)[i * 4 + 3] != NULL) {
                        const char *status = ((char **)response)[i * 4 + 3];
                        int state = OPERATOR_INFO_UNKNOWN;
                        if (status != NULL) {
                            if (strcmp("available", status) == 0) {
                                state = OPERATOR_INFO_AVAILABLE;
                            }
                            else if (strcmp("current", status) == 0) {
                                state = OPERATOR_INFO_CURRENT;
                            }
                            else if (strcmp("forbidden", status) == 0) {
                                state = OPERATOR_INFO_FORBIDDEN;
                            }
                        }
                        operatorInfos[i].state = state;
                    }
                } // end for i ~
            }

            sendData.setToExternal((uint8_t *) operatorInfos, sizeof(OEM_OperatorInfo) * num);
        }
        Return<void> retStatus = radioExeternalService[0]->mOemSlsiRadioExternalRes[clientId]->
            sendRequestRawResponse(responseInfo, sendData);

        if (operatorInfos != NULL) {
            delete[] operatorInfos;
            operatorInfos = NULL;
        }

        radioExeternalService[0]->checkReturnStatus(clientId, slotId, retStatus);
    } else {
        RLOGE("sendRequestRawResponse: Invalid Radio Extern Client ID(=%d) or response object is not registered", clientId);
    }
    return 0;
}
