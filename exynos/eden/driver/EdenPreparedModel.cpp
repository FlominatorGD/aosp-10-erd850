/*
 * Copyright (C) 2019 Samsung Electronics Co. LTD
 *
 * This software is proprietary of Samsung Electronics.
 * No part of this software, either material or conceptual may be copied or distributed, transmitted,
 * transcribed, stored in a retrieval system or translated into any human or computer language in any form by any means,
 * electronic, mechanical, manual or otherwise, or disclosed
 * to third parties without the express written permission of Samsung Electronics.
 */

/**
 * @file    EdenPreparedModel.cpp
 * @brief   This is EdenPreparedModel class file.
 * @details This header implements IPreparedModel interface.
 * @author  minsu.jeon (minsu.jeon@samsung.com)
 */

#include <iostream>
#include <sys/mman.h>  // munmap

#include "log.h"

#include "ExecutionBurstServer.h"  // ExecutionBurstServer
#include "ValidateHal.h"           // validateRequest
#include "Utils.h"                 // convertToV1_0, convertToV1_1, android::nn::initVLogMask, logModelToInfo, DRIVER

#include "EdenPreparedModel.h"
#include "NNAgent.h"               // NNAgent
#include "EdenModelConvertLib.h"   // loadAndroidModelInputToEdenOperation

#ifdef LOG_TAG
#undef LOG_TAG
#endif
#define LOG_TAG "EdenDriver::EdenPreparedModel"

namespace android {
namespace nn {
namespace eden_driver {

static const Timing kNoTiming = {.timeOnDevice = UINT64_MAX, .timeInDriver = UINT64_MAX};

class MyExecutionCallback : public V1_2::IExecutionCallback {
 public:
    MyExecutionCallback(executeSynchronously_cb cb) : myCb(cb) {
    }

    Return<void> notify(ErrorStatus /*status*/) {
        return Void();
    }

    Return<void> notify_1_2(ErrorStatus status, const hidl_vec<OutputShape>& outputShapes, const Timing& timing) {
        myCb(status, outputShapes, timing);
        return Void();
    }

    executeSynchronously_cb myCb;
};

/**
 * @brief EdenPreparedModel constructor
 * @details This function keeps all related information for a given model internally.
 * @param[in] nnAgent instance of NNAgent
 * @param[in] model Android NN Model
 * @param[in] modelId unique model id generated by Eden Runtime service
 * @param[in] edenModel EdenModel
 * @param[in] inputBuffers InHouseBufferInfo representing for buffer information returned by Eden Runtime service
 * @param[in] outputBuffers InHouseBufferInfo representing for buffer information returned by Eden Runtime service
 * @param[in] vecAddr virtual address for buffers on pools
 * @param[in] vecSize size for buffers on pools
 * @param[in] operandValues copied internal operandValues of model
 * @param[in] mapOperandIdFromAToE map operand id from Android NN Model to Eden Model
 * @param[in] mapOperationIdFromAToE map operation id from Android NN Model to Eden Model
 * @param[in] inputConsumers android operation id that consumes an operand at index
 * @param[in] internalBuffers internal buffers allocated for this model
 * @param[in] vecIMemoryOnAshmems list of sp<IMemory> that returned via mapMemory()
 * @returns return code
 */
EdenPreparedModel::EdenPreparedModel(NNAgent* nnAgent,
                                     const V1_2::Model& model, uint32_t modelId, EdenModel* edenModel,
                                     HwPreference hwPreference,
                                     void* inputAddr, int32_t inputNumOfBuffers,
                                     void* outputAddr, int32_t outputNumOfBuffers,
                                     std::vector<char*>& vecMappedAddr, std::vector<int32_t>& vecMappedSize,
                                     std::unique_ptr<uint8_t[]>& operandValues,
                                     std::map<int32_t, int32_t>& mapOperandIdFromAToE,
                                     std::map<int32_t, int32_t>& mapOperationIdFromAToE,
                                     std::vector<int32_t>& inputConsumers,
                                     std::vector<std::unique_ptr<int32_t[]>>& internalBuffers,
                                     std::vector<sp<IMemory>>& vecIMemoryOnAshmems) :
    model(model),
    modelId(modelId),
    hwPreference(hwPreference),
    inputAddr(inputAddr), inputNumOfBuffers(inputNumOfBuffers),
    outputAddr(outputAddr), outputNumOfBuffers(outputNumOfBuffers),
    nnAgent_(nnAgent), edenModel_(edenModel) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);
    LOGD(EDEN_DRIVER, "modelId: %d, inputAddr: %p, inputNumOfBuffers: %d, outputAddr: %p, outputNumOfBuffers: %d is created!\n",
                       modelId, inputAddr, inputNumOfBuffers, outputAddr, outputNumOfBuffers);

    updatedOperations.resize(0);

    vecMappedAddr_ = vecMappedAddr;
    vecMappedSize_ = vecMappedSize;

    operandValues_ = std::move(operandValues);

    mapOperandIdFromAToE_ = mapOperandIdFromAToE;
    mapOperationIdFromAToE_ = mapOperationIdFromAToE;
    inputConsumers_ = inputConsumers;

    for (auto& buffers : internalBuffers) {
        internalBuffers_.push_back(std::move(buffers));
    }

    vecIMemoryOnAshmems_ = vecIMemoryOnAshmems;

    needInputBuffers_ = (inputAddr == nullptr ? true : false);
    needOutputBuffers_ = (outputAddr == nullptr ? true : false);

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
}

/**
 * @brief EdenPreparedModel destructor
 * @details This function releases all related information for a given model internally.
 * @returns
 */
EdenPreparedModel::~EdenPreparedModel() {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);
    // Unmap
    LOGD(EDEN_DRIVER, "Unmap on virtual address...\n");
    for (size_t idx = 0; idx < vecMappedAddr_.size(); idx++) {
        char* mappedAddr = static_cast<char*>(vecMappedAddr_.at(idx));
        delete[] mappedAddr;
    }
    LOGD(EDEN_DRIVER, "Unmap on virtual address...Done!\n");

    if (nnAgent_) {
        nnAgent_->closeModel(modelId);
    }
    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
}

/**
 * @brief execute a given Request
 * @details This function executes a given Request. Once it is complete, result is notified via callback.
 * @param[in] request Request
 * @param[in] callback callback to be executed
 * @returns return code
 */
Return<ErrorStatus> EdenPreparedModel::execute(const V1_0::Request& request, const sp<V1_0::IExecutionCallback>& callback_1_0) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    if (callback_1_0.get() == nullptr) {
        LOGE(EDEN_DRIVER, "Error, invalid callback passed to execute\n");
        return ErrorStatus::INVALID_ARGUMENT;
    }
    if (!validateRequest(request, model)) {
        callback_1_0->notify(ErrorStatus::INVALID_ARGUMENT);
        return ErrorStatus::INVALID_ARGUMENT;
    }

    if (!verifyDimension(request, model)) {
        callback_1_0->notify(ErrorStatus::INVALID_ARGUMENT);
        return ErrorStatus::INVALID_ARGUMENT;
    }

    //show();
    //showRequest(request);

    // Load input data(Android NN Memory) to input buffer(Eden Memory Manager)
    // loadInputData(request);

    // Execute
    int32_t ret = nnAgent_->execute(this, request, callback_1_0);
    if (ret != RET_OK) {
        callback_1_0->notify(ErrorStatus::INVALID_ARGUMENT);
        LOGE(EDEN_DRIVER, "%s(-)\n", __func__);
        return ErrorStatus::INVALID_ARGUMENT;
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return ErrorStatus::NONE;
}

Return<ErrorStatus> EdenPreparedModel::execute_1_2(const V1_0::Request& request,
                                                   V1_2::MeasureTiming measure,
                                                   const sp<V1_2::IExecutionCallback>& callback_1_2) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);
    if (callback_1_2.get() == nullptr) {
        LOGE(EDEN_DRIVER, "Error, invalid callback passed to execute\n");
        return ErrorStatus::INVALID_ARGUMENT;
    }
    if (!validateRequest(request, model)) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        return ErrorStatus::INVALID_ARGUMENT;
    }
    if (!verifyDimension(request, model)) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        return ErrorStatus::INVALID_ARGUMENT;
    }

    // Execute
    int32_t ret = nnAgent_->execute(this, request, measure, callback_1_2);
    if (ret != RET_OK) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        LOGE(EDEN_DRIVER, "%s(-)\n", __func__);
        return ErrorStatus::INVALID_ARGUMENT;
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return ErrorStatus::NONE;
}

Return<void> EdenPreparedModel::executeSynchronously(const V1_0::Request& request,
                                                     V1_2::MeasureTiming measure,
                                                     executeSynchronously_cb cb) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    // Execute
    sp<V1_2::IExecutionCallback> callback_1_2 = new MyExecutionCallback(cb);

    if (!validateRequest(request, model)) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        return Void();
    }

    if (!verifyDimension(request, model)) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        return Void();
    }

    int32_t ret = nnAgent_->executeSynchronously(this, request, measure, callback_1_2);
    if (ret != RET_OK) {
        callback_1_2->notify_1_2(ErrorStatus::INVALID_ARGUMENT, {}, kNoTiming);
        LOGE(EDEN_DRIVER, "%s(-)\n", __func__);
        return Void();
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return Void();
}

Return<void> EdenPreparedModel::configureExecutionBurst(const sp<V1_2::IBurstCallback>& callback,
                                                        const MQDescriptorSync<V1_2::FmqRequestDatum>& requestChannel,
                                                        const MQDescriptorSync<V1_2::FmqResultDatum>& resultChannel,
                                                        configureExecutionBurst_cb cb) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    const sp<V1_2::IBurstContext> burst =
            ExecutionBurstServer::create(callback, requestChannel, resultChannel, this);

    if (burst == nullptr) {
        LOGE(EDEN_DRIVER, "burst is null!");
        cb(ErrorStatus::GENERAL_FAILURE, {});
    } else {
        cb(ErrorStatus::NONE, burst);
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return Void();
}

/**
 * @brief load input data on request and copy them to EdenBuffers for inputs
 * @details This function loads a buffers on request and copy them to EdenBuffers for inputs.
 *          EdenBuffers should be allocated before.
 *          If inputs[idx].hasNoValue==1, it loads 1)default values or 2)set size to 0.
 * @param[in] request Request
 * @returns return code
 */
int32_t EdenPreparedModel::loadInputData(const V1_0::Request& request, BufferInfoOnExecute& bufInfoOnExecute) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    const std::vector<RequestArgument>& inputs = request.inputs;

    for (size_t idx = 0; idx < inputs.size(); idx++) {
        const RequestArgument &inputArgs = inputs[idx];
        if (inputArgs.hasNoValue) {
            LOGD(EDEN_DRIVER, "inputs[%zu].hasNoValue == 1, check if there is any default values for it.\n", idx);;
            loadDefaultDataOnTargetBuffer(idx);
            continue;
        }

        // Get virtual address of input data at #idx
        int32_t poolIndex = inputArgs.location.poolIndex;
        int32_t offset = inputArgs.location.offset;
        int32_t length = inputArgs.location.length;

        char* virtAddr = nullptr;
        int32_t ret = bufInfoOnExecute.loadHidlMem(request.pools[poolIndex], true, virtAddr);
        if (ret != RET_OK) {
            LOGE(EDEN_DRIVER, "%s(-) Fail on getVirtualAddressOnPool!\n", __func__);
            return ret;
        }

        ret = loadDataOnTargetBuffer(virtAddr + offset, length, idx);
        if (ret != RET_OK) {
            LOGE(EDEN_DRIVER, "%s(-) Fail on loadDataOnTargetBuffer!\n", __func__);
            return ret;
        }
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return 0;
}

/**
 * @brief load output data on EdenBuffers for outputs and copy them to output buffers on request
 * @details This function loads a buffers on EdenBuffers for outputs and copy them to output buffers on request.
 *          EdenBuffers should be allocated before.
 * @param[in] request Request
 * @returns return code
 */
int32_t EdenPreparedModel::loadOutputData(const V1_0::Request& request, BufferInfoOnExecute& bufInfoOnExecute) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    const std::vector<RequestArgument>& outputs = request.outputs;

    EdenBuffer* edenBufferForOutputs = reinterpret_cast<EdenBuffer*>(outputAddr);

    for (size_t idx = 0; idx < outputs.size(); idx++) {
        const RequestArgument& outputArgs = outputs[idx];
        if (outputArgs.hasNoValue) {
            continue;
        }

        EdenBuffer* outputBufferAddr = &(edenBufferForOutputs[idx]);
        LOGD(EDEN_DRIVER, "outputBufferAddr addr:%p, size=%d\n", outputBufferAddr->addr, outputBufferAddr->size);

        int32_t poolIndex = outputArgs.location.poolIndex;
        int32_t offset = outputArgs.location.offset;
        int32_t length = outputArgs.location.length;

        char* virtAddr = nullptr;
        int32_t ret = bufInfoOnExecute.loadHidlMem(request.pools[poolIndex], false, virtAddr);
        if (ret != RET_OK) {
            LOGE(EDEN_DRIVER, "%s(-) Fail on getVirtualAddressOnPool!\n", __func__);
            return ret;
        }

        LOGD(EDEN_DRIVER, "Load from %p to %p, length=%d\n", outputBufferAddr->addr, reinterpret_cast<void*>(virtAddr + offset), length);
        bufInfoOnExecute.startUpdate(virtAddr);
        std::memcpy(reinterpret_cast<void*>(virtAddr + offset), outputBufferAddr->addr, length);
        bufInfoOnExecute.endUpdate(virtAddr);
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return 0;
}

int32_t EdenPreparedModel::resolveUnknownDimensions(const V1_0::Request& request) {
    // Resolve input buffer allocation
    bool resolved = true;
    if (needInputBuffers_) {
        // It means input buffer allocation was not executed at preparedModel,
        // which means dimensions for input buffers were unknown at preparedModel.

        const std::vector<RequestArgument>& inputs = request.inputs;

        for (size_t inputIdx = 0; inputIdx < inputs.size(); inputIdx++) {
            const RequestArgument& inputArgs = inputs[inputIdx];
            if (inputArgs.hasNoValue) {
                LOGD(EDEN_DRIVER, "inputs[%zu].hasNoValue == 1, skip it.\n", inputIdx);
                continue;
            }

            // Get android operand id used as model input
            int32_t androidOperandIdx = model.inputIndexes[inputIdx];
            auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
            if (iter != mapOperandIdFromAToE_.end()) {
                LOGD(EDEN_DRIVER, "inputIndexes[%zu] is converted to EdenOperand, id=[%d]\n",
                                   inputIdx, iter->second);
                int32_t edenOperandIdx = iter->second;

                // Get dimensions
                size_t rank = inputArgs.dimensions.size();
                static int32_t newDims[4];
                for (size_t idx = 0; idx < rank; idx++) {
                    newDims[idx] = inputArgs.dimensions[idx];
                }
                for (size_t idx = rank; idx < 4; idx++) {
                    newDims[idx] = 1;
                }

                // Update dimensions of edenOperand on edenModel
                if (rank == 0) {
                    LOGD(EDEN_DRIVER, "edenOperandIdx(%d)'s rank is zero...\n", edenOperandIdx);
                    resolved = false;
                } else {
                    edenModel_->UpdateOperandDimensions(edenOperandIdx, rank, newDims);
                }
            } else {
                LOGD(EDEN_DRIVER, "No matched edenOperand... skip it\n");
                continue;
            }
        }

        if (resolved) {
            needInputBuffers_ = false;
        }
    }

    // Resolve output buffer allocation
    resolved = true;
    if (needOutputBuffers_) {
        // It means output buffer allocation was not executed at preparedModel,
        // which means dimensions for output buffers were unknown at preparedModel.

        const std::vector<RequestArgument>& outputs = request.outputs;

        for (size_t outputIdx = 0; outputIdx < outputs.size(); outputIdx++) {
            const RequestArgument& outputArgs = outputs[outputIdx];

             // Get android operand id used as model output
            int32_t androidOperandIdx = model.outputIndexes[outputIdx];
            auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
            if (iter != mapOperandIdFromAToE_.end()) {
                LOGD(EDEN_DRIVER, "outputIndexes[%zu] is converted to EdenOperand, id=[%d]\n",
                                   outputIdx, iter->second);
                int32_t edenOperandIdx = iter->second;

                bool unknown = false;
                size_t rank = outputArgs.dimensions.size();

                // Check unknown rank, unknown dimension
                if (rank == 0) {
                    unknown = true;
                } else {
                    for (size_t idx = 0; idx < rank; idx++) {
                        if (outputArgs.dimensions[idx] == 0) {
                            unknown = true;
                            break;
                        }
                    }
                }

                if (unknown) {
                    // Need to deduce output size
                    bool ret = edenModel_->DeduceOperandDimensions(edenOperandIdx);
                    if (ret == false) {
                        resolved = false;
                        break;
                    }
                } else {
                    // Get dimensions
                    static int32_t newDims[4];
                    for (size_t idx = 0; idx < rank; idx++) {
                        newDims[idx] = outputArgs.dimensions[idx];
                    }
                    for (size_t idx = rank; idx < 4; idx++) {
                        newDims[idx] = 1;
                    }

                    // Update dimensions of edenOperand on edenModel
                    edenModel_->UpdateOperandDimensions(edenOperandIdx, rank, newDims);
                }
            } else {
                LOGD(EDEN_DRIVER, "No matched edenOperand... skip it\n");
                continue;
            }
        }

        if (resolved) {
            needOutputBuffers_ = false;
        }
    }

    return RET_OK;
}

void EdenPreparedModel::updateInputBuffers(void* addr, int32_t numOfBuffers) {
    inputAddr = addr;
    inputNumOfBuffers = numOfBuffers;
    if (inputAddr) needInputBuffers_ = false;
}

void EdenPreparedModel::updateOutputBuffers(void* addr, int32_t numOfBuffers) {
    outputAddr = addr;
    outputNumOfBuffers = numOfBuffers;
    if (outputAddr) needOutputBuffers_ = false;
}

bool EdenPreparedModel::readyToAllocateInputBuffers(const V1_0::Request* request) {
    const std::vector<RequestArgument>& inputs = request->inputs;

    for (size_t inputIdx = 0; inputIdx < inputs.size(); inputIdx++) {
        // Get android operand id used as model input
        int32_t androidOperandIdx = model.inputIndexes[inputIdx];
        auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
        if (iter != mapOperandIdFromAToE_.end()) {
            LOGD(EDEN_DRIVER, "inputIndexes[%zu] is converted to EdenOperand, id=[%d]\n",
                               inputIdx, iter->second);
            int32_t edenOperandIdx = iter->second;
            const RequestArgument& inputArgs = inputs[inputIdx];
            if (inputArgs.hasNoValue) {
                LOGD(EDEN_DRIVER, "inputs[%zu].hasNoValue == 1, skip it.\n", inputIdx);
            } else {
                if (edenModel_->ReadyToAllocateInputBuffers(&edenOperandIdx) == false) {
                    return false;
                }
            }
        }
    }

    return true;
}

bool EdenPreparedModel::readyToAllocateOutputBuffers(const V1_0::Request* request) {
    const std::vector<RequestArgument>& outputs = request->outputs;

    for (size_t outputIdx = 0; outputIdx < outputs.size(); outputIdx++) {
        // Get android operand id used as model output
        int32_t androidOperandIdx = model.outputIndexes[outputIdx];
        auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
        if (iter != mapOperandIdFromAToE_.end()) {
            LOGD(EDEN_DRIVER, "outputIndexes[%zu] is converted to EdenOperand, id=[%d]\n",
                               outputIdx, iter->second);
            int32_t edenOperandIdx = iter->second;
            const RequestArgument& outputArgs = outputs[outputIdx];
            if (outputArgs.hasNoValue) {
                LOGD(EDEN_DRIVER, "outputs[%zu].hasNoValue == 1, skip it.\n", outputIdx);
            } else {
                if (edenModel_->ReadyToAllocateOutputBuffers(&edenOperandIdx) == false) {
                    return false;
                }
            }
        }
    }

    return true;
}

/**
 * @brief load default values to a target buffer matched to a given input index
 * @details This function loads a default value to a target buffers.
 *          Target buffer is determined based on a given input index.
 *          If there is a target buffer, it loads a default value.
 *          If it is translated as an option, it loads that field on option.
 * @param[in] inputIdx input index on request.inputs
 * @returns return code
 */
int32_t EdenPreparedModel::loadDefaultDataOnTargetBuffer(int32_t inputIdx) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    // Get android operand id used as model input
    int32_t androidOperandIdx = model.inputIndexes[inputIdx];

    // Which operation uses this operand id as input?

    // Case 1. There is matched edenOperand. That means memcpy is enough.
    bool exist = false;
    auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
    if (iter != mapOperandIdFromAToE_.end()) {
        exist = true;
        LOGD(EDEN_DRIVER, "inputIndexes[%d] is converted to EdenOperand, id=[%d]\n", inputIdx, iter->second);
    }

    // 1. Who is the consumer for this input operand?
    int32_t androidOperationIdx = inputConsumers_.at(inputIdx);
    const V1_2::Operation& androidOperation = model.operations[androidOperationIdx];

    // 2. Find index number matched to a given androidOperandIdx
    int32_t indexNumber = 0;
    for (size_t idx = 0; idx < androidOperation.inputs.size(); idx++) {
        if (static_cast<int32_t>(androidOperation.inputs[idx]) == androidOperandIdx) {
            indexNumber = idx;
            break;
        }
    }
    LOGD(EDEN_DRIVER, "androidOperandIdx=[%d] is %dth index!\n", androidOperandIdx, indexNumber);

    if (exist) {  // To be loaded on input buffers
        // @todo Currently, input buffer order and input indexes has same order.
        EdenBuffer* edenBufferForInputs = reinterpret_cast<EdenBuffer*>(inputAddr);
        EdenBuffer* inputBufferAddr = &(edenBufferForInputs[inputIdx]);
        LOGD(EDEN_DRIVER, "inputBufferAddr addr:%p, size=%d\n", inputBufferAddr->addr, inputBufferAddr->size);
        void* targetAddr = inputBufferAddr->addr;
        int32_t targetSize = inputBufferAddr->size;

        LOGD(EDEN_DRIVER, "targetAddr=%p, targetSize=%d\n", targetAddr, targetSize);

        bool loaded = loadDefaultValuesForOptionalInputs(model, indexNumber, androidOperation, static_cast<char*>(targetAddr), targetSize);
        if (loaded == false) {
            // There is no loaded default values on buffer.
            // In this case, it contains invalid values.
            // To avoid use this invalid values by consumers,
            // forcely set buffer size to 0 to indicate there is no valid data on this buffer.
            LOGD(EDEN_DRIVER, "There is no loaded default value on buffer=%p, Forcely set buffer size=0\n", targetAddr);
            inputBufferAddr->size = 0;
        }
    } else {  // To be loaded on a specific position
        // 3. Find edenOperation matched to a given androidOperationIdx
        int32_t edenOperationIdx = mapOperationIdFromAToE_[androidOperationIdx];
        EdenOperation* edenOperation = getEdenOperation(edenModel_, edenOperationIdx);

        // 3.1 Keep updated operations
        updatedOperations.push_back(edenOperationIdx);
        LOGD(EDEN_DRIVER, "push %d, numOfOperations=%d\n", edenOperationIdx, static_cast<int32_t>(updatedOperations.size()));

        // 4. Find edenOperand for options if exists
        void* addrForOptions = nullptr;
        if (edenOperation->hasOptions) {
            int32_t edenOperandIndexForOptions = edenOperation->inputOperandIndexes[edenOperation->numOfInputs - 1];
            EdenOperand* operandForOptions = getEdenOperand(edenModel_, edenOperandIndexForOptions);
            if (operandForOptions->buffer == nullptr) {
                LOGE(EDEN_DRIVER, "Oops, operandForOptions->buffer is NULL! Please check it!\n");
                return BUFFER_ON_OPTION_IS_NULL;
            }
            addrForOptions = operandForOptions->buffer->addr;
        }

        // 5. Load input operand at idx into edenOperation.
//        loadAndroidModelInputToEdenOperation(model, indexNumber, androidOperation, nullptr, 0, addrForOptions);
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return RET_OK;
}

/**
 * @brief load data on a given srcAddr to matched target buffer which is given as an input index
 * @details This function loads data on a given srcAddr to matched target buffer which is given as an input index.
 * @param[in] srcAddr address for data to be loaded
 * @param[in] length length of data
 * @param[in] inputIdx input index on request.inputs
 * @returns return code
 */
int32_t EdenPreparedModel::loadDataOnTargetBuffer(char* srcAddr, int32_t length, int32_t inputIdx) {
    LOGD(EDEN_DRIVER, "%s(+)\n", __func__);

    void* targetAddr = nullptr;
    int32_t targetSize = 0;

    // Get android operand id used as model input
    int32_t androidOperandIdx = model.inputIndexes[inputIdx];

    // Which operation uses this operand id as input?

    // Case 1. There is matched edenOperand. That means memcpy is enough.
    bool exist = false;
    auto iter = mapOperandIdFromAToE_.find(androidOperandIdx);
    if (iter != mapOperandIdFromAToE_.end()) {
        exist = true;
        LOGD(EDEN_DRIVER, "inputIndexes[%d] is converted to EdenOperand, id=[%d]\n", inputIdx, iter->second);
    }

    if (exist) {  // To be loaded on input buffers
        // @todo Currently, input buffer order and input indexes has same order.
        EdenBuffer* edenBufferForInputs = reinterpret_cast<EdenBuffer*>(inputAddr);
        EdenBuffer* inputBufferAddr = &(edenBufferForInputs[inputIdx]);
        LOGD(EDEN_DRIVER, "inputBufferAddr addr:%p, size=%d\n", inputBufferAddr->addr, inputBufferAddr->size);
        targetAddr = inputBufferAddr->addr;
        targetSize = inputBufferAddr->size;

        if (targetAddr == nullptr) {
            LOGD(EDEN_DRIVER, "Oops, targetAddr == nullptr, skip it!\n");
        } else if (targetSize == 0) {
            LOGD(EDEN_DRIVER, "Oops, targetSize == 0, skip it!\n");
        } else {
            LOGD(EDEN_DRIVER, "Load from %p to %p, length=%d\n", reinterpret_cast<void*>(srcAddr), targetAddr, length);
            std::memcpy(targetAddr, reinterpret_cast<void*>(srcAddr), length);
        }
    } else {  // To be loaded on a specific position
        // 1. Who is the consumer for this input operand?
        int32_t androidOperationIdx = inputConsumers_.at(inputIdx);
        const V1_2::Operation& androidOperation = model.operations[androidOperationIdx];

        // 2. Find index number matched to a given androidOperandIdx
        int32_t indexNumber = 0;
        for (size_t idx = 0; idx < androidOperation.inputs.size(); idx++) {
            if (static_cast<int32_t>(androidOperation.inputs[idx]) == androidOperandIdx) {
                indexNumber = idx;
                break;
            }
        }
        LOGD(EDEN_DRIVER, "androidOperandIdx=[%d] is %dth index!\n", androidOperandIdx, indexNumber);

        // 3. Find edenOperation matched to a given androidOperationIdx
        int32_t edenOperationIdx = mapOperationIdFromAToE_[androidOperationIdx];
        EdenOperation* edenOperation = getEdenOperation(edenModel_, edenOperationIdx);

        // 3.1 Keep updated operations
        updatedOperations.push_back(edenOperationIdx);
        LOGD(EDEN_DRIVER, "push %d, numOfOperations=%d\n", edenOperationIdx, static_cast<int32_t>(updatedOperations.size()));

        // 4. Find edenOperand for options if exists
        void* addrForOptions = nullptr;
        if (edenOperation->hasOptions) {
            int32_t edenOperandIndexForOptions = edenOperation->inputOperandIndexes[edenOperation->numOfInputs - 1];
            EdenOperand* operandForOptions = getEdenOperand(edenModel_, edenOperandIndexForOptions);
            if (operandForOptions->buffer == nullptr) {
                LOGE(EDEN_DRIVER, "Oops, operandForOptions->buffer is NULL! Please check it!\n");
                return BUFFER_ON_OPTION_IS_NULL;
            }
            addrForOptions = operandForOptions->buffer->addr;
        }

        // 5. Load input operand at idx into edenOperation.
//        loadAndroidModelInputToEdenOperation(model, indexNumber, androidOperation, srcAddr, length, addrForOptions);
    }

    LOGD(EDEN_DRIVER, "%s(-)\n", __func__);
    return RET_OK;
}

/**
 * @brief show internal data
 * @details This function shows internal variables of EdenPreparedModel.
 * @returns void
 */
void EdenPreparedModel::show() {
    LOGD(EDEN_DRIVER, "modelId:%d\n", modelId);
    LOGD(EDEN_DRIVER, "inputNumOfBuffers:%d\n", inputNumOfBuffers);
    if (inputAddr != nullptr && outputAddr != nullptr) {
        for (int32_t idx = 0; idx < inputNumOfBuffers; idx++) {
            EdenBuffer* inputBufferAddr = reinterpret_cast<EdenBuffer*>(inputAddr) + idx;  // In fact, inputAddr is EdenBuffer
            LOGD(EDEN_DRIVER, "inputBufferAddr[%d]->addr:%p\n", idx, inputBufferAddr->addr);
            LOGD(EDEN_DRIVER, "inputBufferAddr[%d]->size:%d\n", idx, inputBufferAddr->size);
        }
        LOGD(EDEN_DRIVER, "outputNumOfBuffers:%d\n", outputNumOfBuffers);
        for (int32_t idx = 0; idx < outputNumOfBuffers; idx++) {
            EdenBuffer* outputBufferAddr = reinterpret_cast<EdenBuffer*>(outputAddr) + idx;  // In fact, outputAddr is EdenBuffer
            LOGD(EDEN_DRIVER, "outputBufferAddr[%d]->addr:%p\n", idx, outputBufferAddr->addr);
            LOGD(EDEN_DRIVER, "outputBufferAddr[%d]->size:%d\n", idx, outputBufferAddr->size);
        }
        LOGD(EDEN_DRIVER, "vecMappedAddr and vecMappedSize...\n");
        for (size_t idx = 0; idx < vecMappedAddr_.size(); idx++) {
            char* mappedAddr = vecMappedAddr_[idx];
            int32_t mappedSize = vecMappedSize_[idx];
            LOGD(EDEN_DRIVER, "mappedAddr:%p\n", mappedAddr);
            LOGD(EDEN_DRIVER, "mappedSize:%d\n", mappedSize);
        }
    } else {
        LOGE(EDEN_DRIVER, "inputAddr or outputAddr is nullptr!\n");
    }
    LOGD(EDEN_DRIVER, "vecMappedAddr and vecMappedSize...Done!\n");
}

}  // namespace eden_driver
}  // namespace nn
}  // namespace android

